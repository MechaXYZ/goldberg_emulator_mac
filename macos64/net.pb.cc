// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net.proto

#include "net.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR Announce_Other_Peers::Announce_Other_Peers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.ip_)*/0u
  , /*decltype(_impl_.udp_port_)*/0u
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Announce_Other_PeersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Announce_Other_PeersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Announce_Other_PeersDefaultTypeInternal() {}
  union {
    Announce_Other_Peers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Announce_Other_PeersDefaultTypeInternal _Announce_Other_Peers_default_instance_;
PROTOBUF_CONSTEXPR Announce::Announce(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ids_)*/{}
  , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
  , /*decltype(_impl_.peers_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.tcp_port_)*/0u
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AnnounceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnnounceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnnounceDefaultTypeInternal() {}
  union {
    Announce _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnnounceDefaultTypeInternal _Announce_default_instance_;
PROTOBUF_CONSTEXPR Lobby_ValuesEntry_DoNotUse::Lobby_ValuesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Lobby_ValuesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Lobby_ValuesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Lobby_ValuesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Lobby_ValuesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Lobby_ValuesEntry_DoNotUseDefaultTypeInternal _Lobby_ValuesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Lobby_Member_ValuesEntry_DoNotUse::Lobby_Member_ValuesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Lobby_Member_ValuesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Lobby_Member_ValuesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Lobby_Member_ValuesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Lobby_Member_ValuesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Lobby_Member_ValuesEntry_DoNotUseDefaultTypeInternal _Lobby_Member_ValuesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Lobby_Member::Lobby_Member(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Lobby_MemberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Lobby_MemberDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Lobby_MemberDefaultTypeInternal() {}
  union {
    Lobby_Member _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Lobby_MemberDefaultTypeInternal _Lobby_Member_default_instance_;
PROTOBUF_CONSTEXPR Lobby_Gameserver::Lobby_Gameserver(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.ip_)*/0u
  , /*decltype(_impl_.port_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Lobby_GameserverDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Lobby_GameserverDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Lobby_GameserverDefaultTypeInternal() {}
  union {
    Lobby_Gameserver _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Lobby_GameserverDefaultTypeInternal _Lobby_Gameserver_default_instance_;
PROTOBUF_CONSTEXPR Lobby::Lobby(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.gameserver_)*/nullptr
  , /*decltype(_impl_.room_id_)*/uint64_t{0u}
  , /*decltype(_impl_.owner_)*/uint64_t{0u}
  , /*decltype(_impl_.member_limit_)*/0u
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.joinable_)*/false
  , /*decltype(_impl_.deleted_)*/false
  , /*decltype(_impl_.time_deleted_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LobbyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LobbyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LobbyDefaultTypeInternal() {}
  union {
    Lobby _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LobbyDefaultTypeInternal _Lobby_default_instance_;
PROTOBUF_CONSTEXPR Lobby_Messages_MapEntry_DoNotUse::Lobby_Messages_MapEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Lobby_Messages_MapEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Lobby_Messages_MapEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Lobby_Messages_MapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Lobby_Messages_MapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Lobby_Messages_MapEntry_DoNotUseDefaultTypeInternal _Lobby_Messages_MapEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Lobby_Messages::Lobby_Messages(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.map_)*/{}
  , /*decltype(_impl_.bdata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.idata_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Lobby_MessagesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Lobby_MessagesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Lobby_MessagesDefaultTypeInternal() {}
  union {
    Lobby_Messages _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Lobby_MessagesDefaultTypeInternal _Lobby_Messages_default_instance_;
PROTOBUF_CONSTEXPR Low_Level::Low_Level(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Low_LevelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Low_LevelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Low_LevelDefaultTypeInternal() {}
  union {
    Low_Level _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Low_LevelDefaultTypeInternal _Low_Level_default_instance_;
PROTOBUF_CONSTEXPR Network_pb::Network_pb(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.channel_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.time_processed_)*/uint64_t{0u}
  , /*decltype(_impl_.processed_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Network_pbDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Network_pbDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Network_pbDefaultTypeInternal() {}
  union {
    Network_pb _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Network_pbDefaultTypeInternal _Network_pb_default_instance_;
PROTOBUF_CONSTEXPR Network_Old::Network_Old(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.connection_id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.port_)*/0u
  , /*decltype(_impl_.connection_id_from_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Network_OldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Network_OldDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Network_OldDefaultTypeInternal() {}
  union {
    Network_Old _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Network_OldDefaultTypeInternal _Network_Old_default_instance_;
PROTOBUF_CONSTEXPR Networking_Sockets::Networking_Sockets(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.virtual_port_)*/0
  , /*decltype(_impl_.connection_id_)*/uint64_t{0u}
  , /*decltype(_impl_.connection_id_from_)*/uint64_t{0u}
  , /*decltype(_impl_.real_port_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Networking_SocketsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Networking_SocketsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Networking_SocketsDefaultTypeInternal() {}
  union {
    Networking_Sockets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Networking_SocketsDefaultTypeInternal _Networking_Sockets_default_instance_;
PROTOBUF_CONSTEXPR Networking_Messages::Networking_Messages(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.channel_)*/0u
  , /*decltype(_impl_.id_from_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Networking_MessagesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Networking_MessagesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Networking_MessagesDefaultTypeInternal() {}
  union {
    Networking_Messages _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Networking_MessagesDefaultTypeInternal _Networking_Messages_default_instance_;
PROTOBUF_CONSTEXPR Gameserver_ValuesEntry_DoNotUse::Gameserver_ValuesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Gameserver_ValuesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Gameserver_ValuesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Gameserver_ValuesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Gameserver_ValuesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Gameserver_ValuesEntry_DoNotUseDefaultTypeInternal _Gameserver_ValuesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Gameserver::Gameserver(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_.game_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mod_dir_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.server_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.map_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spectator_server_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tags_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gamedata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.region_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.product_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.max_player_count_)*/0u
  , /*decltype(_impl_.bot_player_count_)*/0u
  , /*decltype(_impl_.spectator_port_)*/0u
  , /*decltype(_impl_.num_players_)*/0u
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.dedicated_server_)*/false
  , /*decltype(_impl_.password_protected_)*/false
  , /*decltype(_impl_.secure_)*/false
  , /*decltype(_impl_.offline_)*/false
  , /*decltype(_impl_.ip_)*/0u
  , /*decltype(_impl_.port_)*/0u
  , /*decltype(_impl_.query_port_)*/0u
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GameserverDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameserverDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameserverDefaultTypeInternal() {}
  union {
    Gameserver _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameserverDefaultTypeInternal _Gameserver_default_instance_;
PROTOBUF_CONSTEXPR Friend_RichPresenceEntry_DoNotUse::Friend_RichPresenceEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Friend_RichPresenceEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Friend_RichPresenceEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Friend_RichPresenceEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Friend_RichPresenceEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Friend_RichPresenceEntry_DoNotUseDefaultTypeInternal _Friend_RichPresenceEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Friend::Friend(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rich_presence_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.lobby_id_)*/uint64_t{0u}
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FriendDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FriendDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FriendDefaultTypeInternal() {}
  union {
    Friend _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FriendDefaultTypeInternal _Friend_default_instance_;
PROTOBUF_CONSTEXPR Auth_Ticket::Auth_Ticket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.number_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Auth_TicketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Auth_TicketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Auth_TicketDefaultTypeInternal() {}
  union {
    Auth_Ticket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Auth_TicketDefaultTypeInternal _Auth_Ticket_default_instance_;
PROTOBUF_CONSTEXPR Friend_Messages::Friend_Messages(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.invite_data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct Friend_MessagesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Friend_MessagesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Friend_MessagesDefaultTypeInternal() {}
  union {
    Friend_Messages _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Friend_MessagesDefaultTypeInternal _Friend_Messages_default_instance_;
PROTOBUF_CONSTEXPR Steam_Messages::Steam_Messages(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.message_data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct Steam_MessagesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Steam_MessagesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Steam_MessagesDefaultTypeInternal() {}
  union {
    Steam_Messages _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Steam_MessagesDefaultTypeInternal _Steam_Messages_default_instance_;
PROTOBUF_CONSTEXPR Common_Message::Common_Message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_id_)*/uint64_t{0u}
  , /*decltype(_impl_.dest_id_)*/uint64_t{0u}
  , /*decltype(_impl_.source_ip_)*/0u
  , /*decltype(_impl_.source_port_)*/0u
  , /*decltype(_impl_.messages_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct Common_MessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Common_MessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Common_MessageDefaultTypeInternal() {}
  union {
    Common_Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Common_MessageDefaultTypeInternal _Common_Message_default_instance_;
bool Announce_Types_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Announce_Types_strings[2] = {};

static const char Announce_Types_names[] =
  "PING"
  "PONG";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Announce_Types_entries[] = {
  { {Announce_Types_names + 0, 4}, 0 },
  { {Announce_Types_names + 4, 4}, 1 },
};

static const int Announce_Types_entries_by_number[] = {
  0, // 0 -> PING
  1, // 1 -> PONG
};

const std::string& Announce_Types_Name(
    Announce_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Announce_Types_entries,
          Announce_Types_entries_by_number,
          2, Announce_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Announce_Types_entries,
      Announce_Types_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Announce_Types_strings[idx].get();
}
bool Announce_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Announce_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Announce_Types_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Announce_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Announce_Types Announce::PING;
constexpr Announce_Types Announce::PONG;
constexpr Announce_Types Announce::Types_MIN;
constexpr Announce_Types Announce::Types_MAX;
constexpr int Announce::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Lobby_Messages_Types_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Lobby_Messages_Types_strings[5] = {};

static const char Lobby_Messages_Types_names[] =
  "CHANGE_OWNER"
  "CHAT_MESSAGE"
  "JOIN"
  "LEAVE"
  "MEMBER_DATA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Lobby_Messages_Types_entries[] = {
  { {Lobby_Messages_Types_names + 0, 12}, 2 },
  { {Lobby_Messages_Types_names + 12, 12}, 4 },
  { {Lobby_Messages_Types_names + 24, 4}, 0 },
  { {Lobby_Messages_Types_names + 28, 5}, 1 },
  { {Lobby_Messages_Types_names + 33, 11}, 3 },
};

static const int Lobby_Messages_Types_entries_by_number[] = {
  2, // 0 -> JOIN
  3, // 1 -> LEAVE
  0, // 2 -> CHANGE_OWNER
  4, // 3 -> MEMBER_DATA
  1, // 4 -> CHAT_MESSAGE
};

const std::string& Lobby_Messages_Types_Name(
    Lobby_Messages_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Lobby_Messages_Types_entries,
          Lobby_Messages_Types_entries_by_number,
          5, Lobby_Messages_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Lobby_Messages_Types_entries,
      Lobby_Messages_Types_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Lobby_Messages_Types_strings[idx].get();
}
bool Lobby_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Lobby_Messages_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Lobby_Messages_Types_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Lobby_Messages_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Lobby_Messages_Types Lobby_Messages::JOIN;
constexpr Lobby_Messages_Types Lobby_Messages::LEAVE;
constexpr Lobby_Messages_Types Lobby_Messages::CHANGE_OWNER;
constexpr Lobby_Messages_Types Lobby_Messages::MEMBER_DATA;
constexpr Lobby_Messages_Types Lobby_Messages::CHAT_MESSAGE;
constexpr Lobby_Messages_Types Lobby_Messages::Types_MIN;
constexpr Lobby_Messages_Types Lobby_Messages::Types_MAX;
constexpr int Lobby_Messages::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Low_Level_Types_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Low_Level_Types_strings[3] = {};

static const char Low_Level_Types_names[] =
  "CONNECT"
  "DISCONNECT"
  "HEARTBEAT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Low_Level_Types_entries[] = {
  { {Low_Level_Types_names + 0, 7}, 1 },
  { {Low_Level_Types_names + 7, 10}, 2 },
  { {Low_Level_Types_names + 17, 9}, 0 },
};

static const int Low_Level_Types_entries_by_number[] = {
  2, // 0 -> HEARTBEAT
  0, // 1 -> CONNECT
  1, // 2 -> DISCONNECT
};

const std::string& Low_Level_Types_Name(
    Low_Level_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Low_Level_Types_entries,
          Low_Level_Types_entries_by_number,
          3, Low_Level_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Low_Level_Types_entries,
      Low_Level_Types_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Low_Level_Types_strings[idx].get();
}
bool Low_Level_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Low_Level_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Low_Level_Types_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Low_Level_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Low_Level_Types Low_Level::HEARTBEAT;
constexpr Low_Level_Types Low_Level::CONNECT;
constexpr Low_Level_Types Low_Level::DISCONNECT;
constexpr Low_Level_Types Low_Level::Types_MIN;
constexpr Low_Level_Types Low_Level::Types_MAX;
constexpr int Low_Level::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Network_pb_Types_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Network_pb_Types_strings[2] = {};

static const char Network_pb_Types_names[] =
  "DATA"
  "NEW_CONNECTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Network_pb_Types_entries[] = {
  { {Network_pb_Types_names + 0, 4}, 0 },
  { {Network_pb_Types_names + 4, 14}, 1 },
};

static const int Network_pb_Types_entries_by_number[] = {
  0, // 0 -> DATA
  1, // 1 -> NEW_CONNECTION
};

const std::string& Network_pb_Types_Name(
    Network_pb_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Network_pb_Types_entries,
          Network_pb_Types_entries_by_number,
          2, Network_pb_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Network_pb_Types_entries,
      Network_pb_Types_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Network_pb_Types_strings[idx].get();
}
bool Network_pb_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Network_pb_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Network_pb_Types_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Network_pb_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Network_pb_Types Network_pb::DATA;
constexpr Network_pb_Types Network_pb::NEW_CONNECTION;
constexpr Network_pb_Types Network_pb::Types_MIN;
constexpr Network_pb_Types Network_pb::Types_MAX;
constexpr int Network_pb::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Network_Old_Types_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Network_Old_Types_strings[5] = {};

static const char Network_Old_Types_names[] =
  "CONNECTION_ACCEPTED"
  "CONNECTION_END"
  "CONNECTION_REQUEST_IP"
  "CONNECTION_REQUEST_STEAMID"
  "DATA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Network_Old_Types_entries[] = {
  { {Network_Old_Types_names + 0, 19}, 2 },
  { {Network_Old_Types_names + 19, 14}, 3 },
  { {Network_Old_Types_names + 33, 21}, 0 },
  { {Network_Old_Types_names + 54, 26}, 1 },
  { {Network_Old_Types_names + 80, 4}, 4 },
};

static const int Network_Old_Types_entries_by_number[] = {
  2, // 0 -> CONNECTION_REQUEST_IP
  3, // 1 -> CONNECTION_REQUEST_STEAMID
  0, // 2 -> CONNECTION_ACCEPTED
  1, // 3 -> CONNECTION_END
  4, // 4 -> DATA
};

const std::string& Network_Old_Types_Name(
    Network_Old_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Network_Old_Types_entries,
          Network_Old_Types_entries_by_number,
          5, Network_Old_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Network_Old_Types_entries,
      Network_Old_Types_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Network_Old_Types_strings[idx].get();
}
bool Network_Old_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Network_Old_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Network_Old_Types_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Network_Old_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Network_Old_Types Network_Old::CONNECTION_REQUEST_IP;
constexpr Network_Old_Types Network_Old::CONNECTION_REQUEST_STEAMID;
constexpr Network_Old_Types Network_Old::CONNECTION_ACCEPTED;
constexpr Network_Old_Types Network_Old::CONNECTION_END;
constexpr Network_Old_Types Network_Old::DATA;
constexpr Network_Old_Types Network_Old::Types_MIN;
constexpr Network_Old_Types Network_Old::Types_MAX;
constexpr int Network_Old::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Networking_Sockets_Types_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Networking_Sockets_Types_strings[4] = {};

static const char Networking_Sockets_Types_names[] =
  "CONNECTION_ACCEPTED"
  "CONNECTION_END"
  "CONNECTION_REQUEST"
  "DATA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Networking_Sockets_Types_entries[] = {
  { {Networking_Sockets_Types_names + 0, 19}, 2 },
  { {Networking_Sockets_Types_names + 19, 14}, 3 },
  { {Networking_Sockets_Types_names + 33, 18}, 0 },
  { {Networking_Sockets_Types_names + 51, 4}, 4 },
};

static const int Networking_Sockets_Types_entries_by_number[] = {
  2, // 0 -> CONNECTION_REQUEST
  0, // 2 -> CONNECTION_ACCEPTED
  1, // 3 -> CONNECTION_END
  3, // 4 -> DATA
};

const std::string& Networking_Sockets_Types_Name(
    Networking_Sockets_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Networking_Sockets_Types_entries,
          Networking_Sockets_Types_entries_by_number,
          4, Networking_Sockets_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Networking_Sockets_Types_entries,
      Networking_Sockets_Types_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Networking_Sockets_Types_strings[idx].get();
}
bool Networking_Sockets_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Networking_Sockets_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Networking_Sockets_Types_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Networking_Sockets_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Networking_Sockets_Types Networking_Sockets::CONNECTION_REQUEST;
constexpr Networking_Sockets_Types Networking_Sockets::CONNECTION_ACCEPTED;
constexpr Networking_Sockets_Types Networking_Sockets::CONNECTION_END;
constexpr Networking_Sockets_Types Networking_Sockets::DATA;
constexpr Networking_Sockets_Types Networking_Sockets::Types_MIN;
constexpr Networking_Sockets_Types Networking_Sockets::Types_MAX;
constexpr int Networking_Sockets::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Networking_Messages_Types_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Networking_Messages_Types_strings[4] = {};

static const char Networking_Messages_Types_names[] =
  "CONNECTION_ACCEPT"
  "CONNECTION_END"
  "CONNECTION_NEW"
  "DATA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Networking_Messages_Types_entries[] = {
  { {Networking_Messages_Types_names + 0, 17}, 1 },
  { {Networking_Messages_Types_names + 17, 14}, 2 },
  { {Networking_Messages_Types_names + 31, 14}, 0 },
  { {Networking_Messages_Types_names + 45, 4}, 3 },
};

static const int Networking_Messages_Types_entries_by_number[] = {
  2, // 0 -> CONNECTION_NEW
  0, // 1 -> CONNECTION_ACCEPT
  1, // 2 -> CONNECTION_END
  3, // 3 -> DATA
};

const std::string& Networking_Messages_Types_Name(
    Networking_Messages_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Networking_Messages_Types_entries,
          Networking_Messages_Types_entries_by_number,
          4, Networking_Messages_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Networking_Messages_Types_entries,
      Networking_Messages_Types_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Networking_Messages_Types_strings[idx].get();
}
bool Networking_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Networking_Messages_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Networking_Messages_Types_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Networking_Messages_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Networking_Messages_Types Networking_Messages::CONNECTION_NEW;
constexpr Networking_Messages_Types Networking_Messages::CONNECTION_ACCEPT;
constexpr Networking_Messages_Types Networking_Messages::CONNECTION_END;
constexpr Networking_Messages_Types Networking_Messages::DATA;
constexpr Networking_Messages_Types Networking_Messages::Types_MIN;
constexpr Networking_Messages_Types Networking_Messages::Types_MAX;
constexpr int Networking_Messages::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Auth_Ticket_Types_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Auth_Ticket_Types_strings[1] = {};

static const char Auth_Ticket_Types_names[] =
  "CANCEL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Auth_Ticket_Types_entries[] = {
  { {Auth_Ticket_Types_names + 0, 6}, 0 },
};

static const int Auth_Ticket_Types_entries_by_number[] = {
  0, // 0 -> CANCEL
};

const std::string& Auth_Ticket_Types_Name(
    Auth_Ticket_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Auth_Ticket_Types_entries,
          Auth_Ticket_Types_entries_by_number,
          1, Auth_Ticket_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Auth_Ticket_Types_entries,
      Auth_Ticket_Types_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Auth_Ticket_Types_strings[idx].get();
}
bool Auth_Ticket_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Auth_Ticket_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Auth_Ticket_Types_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<Auth_Ticket_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Auth_Ticket_Types Auth_Ticket::CANCEL;
constexpr Auth_Ticket_Types Auth_Ticket::Types_MIN;
constexpr Auth_Ticket_Types Auth_Ticket::Types_MAX;
constexpr int Auth_Ticket::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Friend_Messages_Types_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Friend_Messages_Types_strings[2] = {};

static const char Friend_Messages_Types_names[] =
  "GAME_INVITE"
  "LOBBY_INVITE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Friend_Messages_Types_entries[] = {
  { {Friend_Messages_Types_names + 0, 11}, 1 },
  { {Friend_Messages_Types_names + 11, 12}, 0 },
};

static const int Friend_Messages_Types_entries_by_number[] = {
  1, // 0 -> LOBBY_INVITE
  0, // 1 -> GAME_INVITE
};

const std::string& Friend_Messages_Types_Name(
    Friend_Messages_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Friend_Messages_Types_entries,
          Friend_Messages_Types_entries_by_number,
          2, Friend_Messages_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Friend_Messages_Types_entries,
      Friend_Messages_Types_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Friend_Messages_Types_strings[idx].get();
}
bool Friend_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Friend_Messages_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Friend_Messages_Types_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Friend_Messages_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Friend_Messages_Types Friend_Messages::LOBBY_INVITE;
constexpr Friend_Messages_Types Friend_Messages::GAME_INVITE;
constexpr Friend_Messages_Types Friend_Messages::Types_MIN;
constexpr Friend_Messages_Types Friend_Messages::Types_MAX;
constexpr int Friend_Messages::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Steam_Messages_Types_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Steam_Messages_Types_strings[1] = {};

static const char Steam_Messages_Types_names[] =
  "FRIEND_CHAT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Steam_Messages_Types_entries[] = {
  { {Steam_Messages_Types_names + 0, 11}, 0 },
};

static const int Steam_Messages_Types_entries_by_number[] = {
  0, // 0 -> FRIEND_CHAT
};

const std::string& Steam_Messages_Types_Name(
    Steam_Messages_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Steam_Messages_Types_entries,
          Steam_Messages_Types_entries_by_number,
          1, Steam_Messages_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Steam_Messages_Types_entries,
      Steam_Messages_Types_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Steam_Messages_Types_strings[idx].get();
}
bool Steam_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Steam_Messages_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Steam_Messages_Types_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<Steam_Messages_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Steam_Messages_Types Steam_Messages::FRIEND_CHAT;
constexpr Steam_Messages_Types Steam_Messages::Types_MIN;
constexpr Steam_Messages_Types Steam_Messages::Types_MAX;
constexpr int Steam_Messages::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Announce_Other_Peers::_Internal {
 public:
};

Announce_Other_Peers::Announce_Other_Peers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Announce.Other_Peers)
}
Announce_Other_Peers::Announce_Other_Peers(const Announce_Other_Peers& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Announce_Other_Peers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.udp_port_){}
    , decltype(_impl_.appid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:Announce.Other_Peers)
}

inline void Announce_Other_Peers::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.ip_){0u}
    , decltype(_impl_.udp_port_){0u}
    , decltype(_impl_.appid_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Announce_Other_Peers::~Announce_Other_Peers() {
  // @@protoc_insertion_point(destructor:Announce.Other_Peers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Announce_Other_Peers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Announce_Other_Peers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Announce_Other_Peers::Clear() {
// @@protoc_insertion_point(message_clear_start:Announce.Other_Peers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.appid_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.appid_));
  _internal_metadata_.Clear<std::string>();
}

const char* Announce_Other_Peers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 udp_port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.udp_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 appid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Announce_Other_Peers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Announce.Other_Peers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // uint32 ip = 2;
  if (this->_internal_ip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ip(), target);
  }

  // uint32 udp_port = 3;
  if (this->_internal_udp_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_udp_port(), target);
  }

  // uint32 appid = 4;
  if (this->_internal_appid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_appid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Announce.Other_Peers)
  return target;
}

size_t Announce_Other_Peers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Announce.Other_Peers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  // uint32 ip = 2;
  if (this->_internal_ip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip());
  }

  // uint32 udp_port = 3;
  if (this->_internal_udp_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_udp_port());
  }

  // uint32 appid = 4;
  if (this->_internal_appid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Announce_Other_Peers::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Announce_Other_Peers*>(
      &from));
}

void Announce_Other_Peers::MergeFrom(const Announce_Other_Peers& from) {
  Announce_Other_Peers* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Announce.Other_Peers)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_ip() != 0) {
    _this->_internal_set_ip(from._internal_ip());
  }
  if (from._internal_udp_port() != 0) {
    _this->_internal_set_udp_port(from._internal_udp_port());
  }
  if (from._internal_appid() != 0) {
    _this->_internal_set_appid(from._internal_appid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Announce_Other_Peers::CopyFrom(const Announce_Other_Peers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Announce.Other_Peers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Announce_Other_Peers::IsInitialized() const {
  return true;
}

void Announce_Other_Peers::InternalSwap(Announce_Other_Peers* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Announce_Other_Peers, _impl_.appid_)
      + sizeof(Announce_Other_Peers::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(Announce_Other_Peers, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string Announce_Other_Peers::GetTypeName() const {
  return "Announce.Other_Peers";
}


// ===================================================================

class Announce::_Internal {
 public:
};

Announce::Announce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Announce)
}
Announce::Announce(const Announce& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Announce* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){from._impl_.ids_}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , decltype(_impl_.peers_){from._impl_.peers_}
    , decltype(_impl_.type_){}
    , decltype(_impl_.tcp_port_){}
    , decltype(_impl_.appid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:Announce)
}

inline void Announce::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){arena}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , decltype(_impl_.peers_){arena}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.tcp_port_){0u}
    , decltype(_impl_.appid_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Announce::~Announce() {
  // @@protoc_insertion_point(destructor:Announce)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Announce::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ids_.~RepeatedField();
  _impl_.peers_.~RepeatedPtrField();
}

void Announce::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Announce::Clear() {
// @@protoc_insertion_point(message_clear_start:Announce)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ids_.Clear();
  _impl_.peers_.Clear();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.appid_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.appid_));
  _internal_metadata_.Clear<std::string>();
}

const char* Announce::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Announce.Types type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Announce_Types>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 tcp_port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.tcp_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Announce.Other_Peers peers = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 appid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Announce::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Announce)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Announce.Types type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // repeated uint64 ids = 2;
  {
    int byte_size = _impl_._ids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          2, _internal_ids(), byte_size, target);
    }
  }

  // uint32 tcp_port = 3;
  if (this->_internal_tcp_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_tcp_port(), target);
  }

  // repeated .Announce.Other_Peers peers = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_peers_size()); i < n; i++) {
    const auto& repfield = this->_internal_peers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 appid = 5;
  if (this->_internal_appid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_appid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Announce)
  return target;
}

size_t Announce::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Announce)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 ids = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.ids_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._ids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .Announce.Other_Peers peers = 4;
  total_size += 1UL * this->_internal_peers_size();
  for (const auto& msg : this->_impl_.peers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .Announce.Types type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 tcp_port = 3;
  if (this->_internal_tcp_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tcp_port());
  }

  // uint32 appid = 5;
  if (this->_internal_appid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Announce::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Announce*>(
      &from));
}

void Announce::MergeFrom(const Announce& from) {
  Announce* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Announce)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ids_.MergeFrom(from._impl_.ids_);
  _this->_impl_.peers_.MergeFrom(from._impl_.peers_);
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_tcp_port() != 0) {
    _this->_internal_set_tcp_port(from._internal_tcp_port());
  }
  if (from._internal_appid() != 0) {
    _this->_internal_set_appid(from._internal_appid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Announce::CopyFrom(const Announce& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Announce)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Announce::IsInitialized() const {
  return true;
}

void Announce::InternalSwap(Announce* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ids_.InternalSwap(&other->_impl_.ids_);
  _impl_.peers_.InternalSwap(&other->_impl_.peers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Announce, _impl_.appid_)
      + sizeof(Announce::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(Announce, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

std::string Announce::GetTypeName() const {
  return "Announce";
}


// ===================================================================

Lobby_ValuesEntry_DoNotUse::Lobby_ValuesEntry_DoNotUse() {}
Lobby_ValuesEntry_DoNotUse::Lobby_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Lobby_ValuesEntry_DoNotUse::MergeFrom(const Lobby_ValuesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

Lobby_Member_ValuesEntry_DoNotUse::Lobby_Member_ValuesEntry_DoNotUse() {}
Lobby_Member_ValuesEntry_DoNotUse::Lobby_Member_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Lobby_Member_ValuesEntry_DoNotUse::MergeFrom(const Lobby_Member_ValuesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Lobby_Member::_Internal {
 public:
};

Lobby_Member::Lobby_Member(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Lobby.Member)
}
Lobby_Member::Lobby_Member(const Lobby_Member& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Lobby_Member* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.values_)*/{}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:Lobby.Member)
}

inline void Lobby_Member::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.values_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Lobby_Member::~Lobby_Member() {
  // @@protoc_insertion_point(destructor:Lobby.Member)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Lobby_Member::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.values_.Destruct();
  _impl_.values_.~MapFieldLite();
}

void Lobby_Member::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Lobby_Member::Clear() {
// @@protoc_insertion_point(message_clear_start:Lobby.Member)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_.Clear();
  _impl_.id_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* Lobby_Member::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.values_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Lobby_Member::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Lobby.Member)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // map<string, bytes> values = 2;
  if (!this->_internal_values().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Lobby_Member_ValuesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_values();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "Lobby.Member.ValuesEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Lobby.Member)
  return target;
}

size_t Lobby_Member::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Lobby.Member)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> values = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_values_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_values().begin();
      it != this->_internal_values().end(); ++it) {
    total_size += Lobby_Member_ValuesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Lobby_Member::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Lobby_Member*>(
      &from));
}

void Lobby_Member::MergeFrom(const Lobby_Member& from) {
  Lobby_Member* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Lobby.Member)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Lobby_Member::CopyFrom(const Lobby_Member& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Lobby.Member)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lobby_Member::IsInitialized() const {
  return true;
}

void Lobby_Member::InternalSwap(Lobby_Member* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
  swap(_impl_.id_, other->_impl_.id_);
}

std::string Lobby_Member::GetTypeName() const {
  return "Lobby.Member";
}


// ===================================================================

class Lobby_Gameserver::_Internal {
 public:
};

Lobby_Gameserver::Lobby_Gameserver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Lobby.Gameserver)
}
Lobby_Gameserver::Lobby_Gameserver(const Lobby_Gameserver& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Lobby_Gameserver* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.port_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.port_));
  // @@protoc_insertion_point(copy_constructor:Lobby.Gameserver)
}

inline void Lobby_Gameserver::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.ip_){0u}
    , decltype(_impl_.port_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Lobby_Gameserver::~Lobby_Gameserver() {
  // @@protoc_insertion_point(destructor:Lobby.Gameserver)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Lobby_Gameserver::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Lobby_Gameserver::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Lobby_Gameserver::Clear() {
// @@protoc_insertion_point(message_clear_start:Lobby.Gameserver)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.port_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.port_));
  _internal_metadata_.Clear<std::string>();
}

const char* Lobby_Gameserver::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Lobby_Gameserver::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Lobby.Gameserver)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // uint32 ip = 2;
  if (this->_internal_ip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ip(), target);
  }

  // uint32 port = 3;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Lobby.Gameserver)
  return target;
}

size_t Lobby_Gameserver::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Lobby.Gameserver)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  // uint32 ip = 2;
  if (this->_internal_ip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip());
  }

  // uint32 port = 3;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Lobby_Gameserver::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Lobby_Gameserver*>(
      &from));
}

void Lobby_Gameserver::MergeFrom(const Lobby_Gameserver& from) {
  Lobby_Gameserver* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Lobby.Gameserver)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_ip() != 0) {
    _this->_internal_set_ip(from._internal_ip());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Lobby_Gameserver::CopyFrom(const Lobby_Gameserver& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Lobby.Gameserver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lobby_Gameserver::IsInitialized() const {
  return true;
}

void Lobby_Gameserver::InternalSwap(Lobby_Gameserver* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Lobby_Gameserver, _impl_.port_)
      + sizeof(Lobby_Gameserver::_impl_.port_)
      - PROTOBUF_FIELD_OFFSET(Lobby_Gameserver, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string Lobby_Gameserver::GetTypeName() const {
  return "Lobby.Gameserver";
}


// ===================================================================

class Lobby::_Internal {
 public:
  static const ::Lobby_Gameserver& gameserver(const Lobby* msg);
};

const ::Lobby_Gameserver&
Lobby::_Internal::gameserver(const Lobby* msg) {
  return *msg->_impl_.gameserver_;
}
Lobby::Lobby(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Lobby)
}
Lobby::Lobby(const Lobby& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Lobby* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.values_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.gameserver_){nullptr}
    , decltype(_impl_.room_id_){}
    , decltype(_impl_.owner_){}
    , decltype(_impl_.member_limit_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.joinable_){}
    , decltype(_impl_.deleted_){}
    , decltype(_impl_.time_deleted_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  if (from._internal_has_gameserver()) {
    _this->_impl_.gameserver_ = new ::Lobby_Gameserver(*from._impl_.gameserver_);
  }
  ::memcpy(&_impl_.room_id_, &from._impl_.room_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_deleted_) -
    reinterpret_cast<char*>(&_impl_.room_id_)) + sizeof(_impl_.time_deleted_));
  // @@protoc_insertion_point(copy_constructor:Lobby)
}

inline void Lobby::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.values_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.gameserver_){nullptr}
    , decltype(_impl_.room_id_){uint64_t{0u}}
    , decltype(_impl_.owner_){uint64_t{0u}}
    , decltype(_impl_.member_limit_){0u}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.joinable_){false}
    , decltype(_impl_.deleted_){false}
    , decltype(_impl_.time_deleted_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Lobby::~Lobby() {
  // @@protoc_insertion_point(destructor:Lobby)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Lobby::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.values_.Destruct();
  _impl_.values_.~MapFieldLite();
  _impl_.members_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.gameserver_;
}

void Lobby::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Lobby::Clear() {
// @@protoc_insertion_point(message_clear_start:Lobby)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_.Clear();
  _impl_.members_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.gameserver_ != nullptr) {
    delete _impl_.gameserver_;
  }
  _impl_.gameserver_ = nullptr;
  ::memset(&_impl_.room_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.time_deleted_) -
      reinterpret_cast<char*>(&_impl_.room_id_)) + sizeof(_impl_.time_deleted_));
  _internal_metadata_.Clear<std::string>();
}

const char* Lobby::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 room_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.room_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 owner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.owner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.values_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Lobby.Member members = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_members(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .Lobby.Gameserver gameserver = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameserver(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 member_limit = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.member_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool joinable = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.joinable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 appid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool deleted = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _impl_.deleted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 time_deleted = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.time_deleted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Lobby::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Lobby)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 room_id = 1;
  if (this->_internal_room_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_room_id(), target);
  }

  // uint64 owner = 2;
  if (this->_internal_owner() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_owner(), target);
  }

  // map<string, bytes> values = 3;
  if (!this->_internal_values().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Lobby_ValuesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_values();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "Lobby.ValuesEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated .Lobby.Member members = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_members_size()); i < n; i++) {
    const auto& repfield = this->_internal_members(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .Lobby.Gameserver gameserver = 5;
  if (this->_internal_has_gameserver()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::gameserver(this),
        _Internal::gameserver(this).GetCachedSize(), target, stream);
  }

  // uint32 member_limit = 6;
  if (this->_internal_member_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_member_limit(), target);
  }

  // uint32 type = 7;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_type(), target);
  }

  // bool joinable = 8;
  if (this->_internal_joinable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_joinable(), target);
  }

  // uint32 appid = 9;
  if (this->_internal_appid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_appid(), target);
  }

  // bool deleted = 32;
  if (this->_internal_deleted() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(32, this->_internal_deleted(), target);
  }

  // uint64 time_deleted = 33;
  if (this->_internal_time_deleted() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(33, this->_internal_time_deleted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Lobby)
  return target;
}

size_t Lobby::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Lobby)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> values = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_values_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_values().begin();
      it != this->_internal_values().end(); ++it) {
    total_size += Lobby_ValuesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .Lobby.Member members = 4;
  total_size += 1UL * this->_internal_members_size();
  for (const auto& msg : this->_impl_.members_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .Lobby.Gameserver gameserver = 5;
  if (this->_internal_has_gameserver()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.gameserver_);
  }

  // uint64 room_id = 1;
  if (this->_internal_room_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_room_id());
  }

  // uint64 owner = 2;
  if (this->_internal_owner() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_owner());
  }

  // uint32 member_limit = 6;
  if (this->_internal_member_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_member_limit());
  }

  // uint32 type = 7;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  // uint32 appid = 9;
  if (this->_internal_appid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
  }

  // bool joinable = 8;
  if (this->_internal_joinable() != 0) {
    total_size += 1 + 1;
  }

  // bool deleted = 32;
  if (this->_internal_deleted() != 0) {
    total_size += 2 + 1;
  }

  // uint64 time_deleted = 33;
  if (this->_internal_time_deleted() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_time_deleted());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Lobby::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Lobby*>(
      &from));
}

void Lobby::MergeFrom(const Lobby& from) {
  Lobby* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Lobby)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  _this->_impl_.members_.MergeFrom(from._impl_.members_);
  if (from._internal_has_gameserver()) {
    _this->_internal_mutable_gameserver()->::Lobby_Gameserver::MergeFrom(
        from._internal_gameserver());
  }
  if (from._internal_room_id() != 0) {
    _this->_internal_set_room_id(from._internal_room_id());
  }
  if (from._internal_owner() != 0) {
    _this->_internal_set_owner(from._internal_owner());
  }
  if (from._internal_member_limit() != 0) {
    _this->_internal_set_member_limit(from._internal_member_limit());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_appid() != 0) {
    _this->_internal_set_appid(from._internal_appid());
  }
  if (from._internal_joinable() != 0) {
    _this->_internal_set_joinable(from._internal_joinable());
  }
  if (from._internal_deleted() != 0) {
    _this->_internal_set_deleted(from._internal_deleted());
  }
  if (from._internal_time_deleted() != 0) {
    _this->_internal_set_time_deleted(from._internal_time_deleted());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Lobby::CopyFrom(const Lobby& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Lobby)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lobby::IsInitialized() const {
  return true;
}

void Lobby::InternalSwap(Lobby* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
  _impl_.members_.InternalSwap(&other->_impl_.members_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Lobby, _impl_.time_deleted_)
      + sizeof(Lobby::_impl_.time_deleted_)
      - PROTOBUF_FIELD_OFFSET(Lobby, _impl_.gameserver_)>(
          reinterpret_cast<char*>(&_impl_.gameserver_),
          reinterpret_cast<char*>(&other->_impl_.gameserver_));
}

std::string Lobby::GetTypeName() const {
  return "Lobby";
}


// ===================================================================

Lobby_Messages_MapEntry_DoNotUse::Lobby_Messages_MapEntry_DoNotUse() {}
Lobby_Messages_MapEntry_DoNotUse::Lobby_Messages_MapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Lobby_Messages_MapEntry_DoNotUse::MergeFrom(const Lobby_Messages_MapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Lobby_Messages::_Internal {
 public:
};

Lobby_Messages::Lobby_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Lobby_Messages)
}
Lobby_Messages::Lobby_Messages(const Lobby_Messages& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Lobby_Messages* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.map_)*/{}
    , decltype(_impl_.bdata_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.idata_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.map_.MergeFrom(from._impl_.map_);
  _impl_.bdata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bdata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bdata().empty()) {
    _this->_impl_.bdata_.Set(from._internal_bdata(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Lobby_Messages)
}

inline void Lobby_Messages::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.map_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.bdata_){}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.idata_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.bdata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bdata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Lobby_Messages::~Lobby_Messages() {
  // @@protoc_insertion_point(destructor:Lobby_Messages)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Lobby_Messages::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.map_.Destruct();
  _impl_.map_.~MapFieldLite();
  _impl_.bdata_.Destroy();
}

void Lobby_Messages::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Lobby_Messages::Clear() {
// @@protoc_insertion_point(message_clear_start:Lobby_Messages)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.map_.Clear();
  _impl_.bdata_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<std::string>();
}

const char* Lobby_Messages::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Lobby_Messages.Types type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Lobby_Messages_Types>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 idata = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.idata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes bdata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_bdata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Lobby_Messages::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Lobby_Messages)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // .Lobby_Messages.Types type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // uint64 idata = 3;
  if (this->_internal_idata() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_idata(), target);
  }

  // bytes bdata = 4;
  if (!this->_internal_bdata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_bdata(), target);
  }

  // map<string, bytes> map = 5;
  if (!this->_internal_map().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Lobby_Messages_MapEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_map();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "Lobby_Messages.MapEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Lobby_Messages)
  return target;
}

size_t Lobby_Messages::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Lobby_Messages)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> map = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_map().begin();
      it != this->_internal_map().end(); ++it) {
    total_size += Lobby_Messages_MapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // bytes bdata = 4;
  if (!this->_internal_bdata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_bdata());
  }

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  // uint64 idata = 3;
  if (this->_internal_idata() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_idata());
  }

  // .Lobby_Messages.Types type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Lobby_Messages::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Lobby_Messages*>(
      &from));
}

void Lobby_Messages::MergeFrom(const Lobby_Messages& from) {
  Lobby_Messages* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Lobby_Messages)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.map_.MergeFrom(from._impl_.map_);
  if (!from._internal_bdata().empty()) {
    _this->_internal_set_bdata(from._internal_bdata());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_idata() != 0) {
    _this->_internal_set_idata(from._internal_idata());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Lobby_Messages::CopyFrom(const Lobby_Messages& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Lobby_Messages)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lobby_Messages::IsInitialized() const {
  return true;
}

void Lobby_Messages::InternalSwap(Lobby_Messages* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.map_.InternalSwap(&other->_impl_.map_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bdata_, lhs_arena,
      &other->_impl_.bdata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Lobby_Messages, _impl_.type_)
      + sizeof(Lobby_Messages::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(Lobby_Messages, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string Lobby_Messages::GetTypeName() const {
  return "Lobby_Messages";
}


// ===================================================================

class Low_Level::_Internal {
 public:
};

Low_Level::Low_Level(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Low_Level)
}
Low_Level::Low_Level(const Low_Level& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Low_Level* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:Low_Level)
}

inline void Low_Level::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Low_Level::~Low_Level() {
  // @@protoc_insertion_point(destructor:Low_Level)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Low_Level::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Low_Level::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Low_Level::Clear() {
// @@protoc_insertion_point(message_clear_start:Low_Level)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Low_Level::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Low_Level.Types type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Low_Level_Types>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Low_Level::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Low_Level)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Low_Level.Types type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Low_Level)
  return target;
}

size_t Low_Level::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Low_Level)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Low_Level.Types type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Low_Level::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Low_Level*>(
      &from));
}

void Low_Level::MergeFrom(const Low_Level& from) {
  Low_Level* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Low_Level)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Low_Level::CopyFrom(const Low_Level& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Low_Level)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Low_Level::IsInitialized() const {
  return true;
}

void Low_Level::InternalSwap(Low_Level* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
}

std::string Low_Level::GetTypeName() const {
  return "Low_Level";
}


// ===================================================================

class Network_pb::_Internal {
 public:
};

Network_pb::Network_pb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Network_pb)
}
Network_pb::Network_pb(const Network_pb& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Network_pb* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.time_processed_){}
    , decltype(_impl_.processed_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.channel_, &from._impl_.channel_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.processed_) -
    reinterpret_cast<char*>(&_impl_.channel_)) + sizeof(_impl_.processed_));
  // @@protoc_insertion_point(copy_constructor:Network_pb)
}

inline void Network_pb::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.channel_){0u}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.time_processed_){uint64_t{0u}}
    , decltype(_impl_.processed_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Network_pb::~Network_pb() {
  // @@protoc_insertion_point(destructor:Network_pb)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Network_pb::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void Network_pb::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Network_pb::Clear() {
// @@protoc_insertion_point(message_clear_start:Network_pb)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  ::memset(&_impl_.channel_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.processed_) -
      reinterpret_cast<char*>(&_impl_.channel_)) + sizeof(_impl_.processed_));
  _internal_metadata_.Clear<std::string>();
}

const char* Network_pb::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 channel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Network_pb.Types type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Network_pb_Types>(val));
        } else
          goto handle_unusual;
        continue;
      // bool processed = 128;
      case 128:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _impl_.processed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 time_processed = 129;
      case 129:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.time_processed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Network_pb::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Network_pb)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 channel = 1;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_channel(), target);
  }

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // .Network_pb.Types type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // bool processed = 128;
  if (this->_internal_processed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(128, this->_internal_processed(), target);
  }

  // uint64 time_processed = 129;
  if (this->_internal_time_processed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(129, this->_internal_time_processed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Network_pb)
  return target;
}

size_t Network_pb::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Network_pb)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // uint32 channel = 1;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel());
  }

  // .Network_pb.Types type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint64 time_processed = 129;
  if (this->_internal_time_processed() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_time_processed());
  }

  // bool processed = 128;
  if (this->_internal_processed() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Network_pb::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Network_pb*>(
      &from));
}

void Network_pb::MergeFrom(const Network_pb& from) {
  Network_pb* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Network_pb)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_time_processed() != 0) {
    _this->_internal_set_time_processed(from._internal_time_processed());
  }
  if (from._internal_processed() != 0) {
    _this->_internal_set_processed(from._internal_processed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Network_pb::CopyFrom(const Network_pb& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Network_pb)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Network_pb::IsInitialized() const {
  return true;
}

void Network_pb::InternalSwap(Network_pb* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Network_pb, _impl_.processed_)
      + sizeof(Network_pb::_impl_.processed_)
      - PROTOBUF_FIELD_OFFSET(Network_pb, _impl_.channel_)>(
          reinterpret_cast<char*>(&_impl_.channel_),
          reinterpret_cast<char*>(&other->_impl_.channel_));
}

std::string Network_pb::GetTypeName() const {
  return "Network_pb";
}


// ===================================================================

class Network_Old::_Internal {
 public:
};

Network_Old::Network_Old(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Network_Old)
}
Network_Old::Network_Old(const Network_Old& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Network_Old* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.connection_id_from_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.connection_id_, &from._impl_.connection_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.connection_id_from_) -
    reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.connection_id_from_));
  // @@protoc_insertion_point(copy_constructor:Network_Old)
}

inline void Network_Old::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.connection_id_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.port_){0u}
    , decltype(_impl_.connection_id_from_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Network_Old::~Network_Old() {
  // @@protoc_insertion_point(destructor:Network_Old)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Network_Old::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void Network_Old::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Network_Old::Clear() {
// @@protoc_insertion_point(message_clear_start:Network_Old)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  ::memset(&_impl_.connection_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.connection_id_from_) -
      reinterpret_cast<char*>(&_impl_.connection_id_)) + sizeof(_impl_.connection_id_from_));
  _internal_metadata_.Clear<std::string>();
}

const char* Network_Old::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Network_Old.Types type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Network_Old_Types>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 connection_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 connection_id_from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.connection_id_from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Network_Old::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Network_Old)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Network_Old.Types type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // uint64 connection_id = 2;
  if (this->_internal_connection_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_connection_id(), target);
  }

  // uint64 connection_id_from = 3;
  if (this->_internal_connection_id_from() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_connection_id_from(), target);
  }

  // uint32 port = 4;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_port(), target);
  }

  // bytes data = 5;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Network_Old)
  return target;
}

size_t Network_Old::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Network_Old)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 5;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // uint64 connection_id = 2;
  if (this->_internal_connection_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_connection_id());
  }

  // .Network_Old.Types type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 port = 4;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  // uint64 connection_id_from = 3;
  if (this->_internal_connection_id_from() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_connection_id_from());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Network_Old::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Network_Old*>(
      &from));
}

void Network_Old::MergeFrom(const Network_Old& from) {
  Network_Old* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Network_Old)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_connection_id() != 0) {
    _this->_internal_set_connection_id(from._internal_connection_id());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  if (from._internal_connection_id_from() != 0) {
    _this->_internal_set_connection_id_from(from._internal_connection_id_from());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Network_Old::CopyFrom(const Network_Old& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Network_Old)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Network_Old::IsInitialized() const {
  return true;
}

void Network_Old::InternalSwap(Network_Old* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Network_Old, _impl_.connection_id_from_)
      + sizeof(Network_Old::_impl_.connection_id_from_)
      - PROTOBUF_FIELD_OFFSET(Network_Old, _impl_.connection_id_)>(
          reinterpret_cast<char*>(&_impl_.connection_id_),
          reinterpret_cast<char*>(&other->_impl_.connection_id_));
}

std::string Network_Old::GetTypeName() const {
  return "Network_Old";
}


// ===================================================================

class Networking_Sockets::_Internal {
 public:
};

Networking_Sockets::Networking_Sockets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Networking_Sockets)
}
Networking_Sockets::Networking_Sockets(const Networking_Sockets& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Networking_Sockets* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.virtual_port_){}
    , decltype(_impl_.connection_id_){}
    , decltype(_impl_.connection_id_from_){}
    , decltype(_impl_.real_port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.real_port_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.real_port_));
  // @@protoc_insertion_point(copy_constructor:Networking_Sockets)
}

inline void Networking_Sockets::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.virtual_port_){0}
    , decltype(_impl_.connection_id_){uint64_t{0u}}
    , decltype(_impl_.connection_id_from_){uint64_t{0u}}
    , decltype(_impl_.real_port_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Networking_Sockets::~Networking_Sockets() {
  // @@protoc_insertion_point(destructor:Networking_Sockets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Networking_Sockets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void Networking_Sockets::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Networking_Sockets::Clear() {
// @@protoc_insertion_point(message_clear_start:Networking_Sockets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.real_port_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.real_port_));
  _internal_metadata_.Clear<std::string>();
}

const char* Networking_Sockets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Networking_Sockets.Types type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Networking_Sockets_Types>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 virtual_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.virtual_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 connection_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.connection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 connection_id_from = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.connection_id_from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 real_port = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.real_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Networking_Sockets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Networking_Sockets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Networking_Sockets.Types type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // int32 virtual_port = 2;
  if (this->_internal_virtual_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_virtual_port(), target);
  }

  // uint64 connection_id = 3;
  if (this->_internal_connection_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_connection_id(), target);
  }

  // uint64 connection_id_from = 4;
  if (this->_internal_connection_id_from() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_connection_id_from(), target);
  }

  // bytes data = 5;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_data(), target);
  }

  // int32 real_port = 6;
  if (this->_internal_real_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_real_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Networking_Sockets)
  return target;
}

size_t Networking_Sockets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Networking_Sockets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 5;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // .Networking_Sockets.Types type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 virtual_port = 2;
  if (this->_internal_virtual_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_virtual_port());
  }

  // uint64 connection_id = 3;
  if (this->_internal_connection_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_connection_id());
  }

  // uint64 connection_id_from = 4;
  if (this->_internal_connection_id_from() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_connection_id_from());
  }

  // int32 real_port = 6;
  if (this->_internal_real_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_real_port());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Networking_Sockets::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Networking_Sockets*>(
      &from));
}

void Networking_Sockets::MergeFrom(const Networking_Sockets& from) {
  Networking_Sockets* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Networking_Sockets)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_virtual_port() != 0) {
    _this->_internal_set_virtual_port(from._internal_virtual_port());
  }
  if (from._internal_connection_id() != 0) {
    _this->_internal_set_connection_id(from._internal_connection_id());
  }
  if (from._internal_connection_id_from() != 0) {
    _this->_internal_set_connection_id_from(from._internal_connection_id_from());
  }
  if (from._internal_real_port() != 0) {
    _this->_internal_set_real_port(from._internal_real_port());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Networking_Sockets::CopyFrom(const Networking_Sockets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Networking_Sockets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Networking_Sockets::IsInitialized() const {
  return true;
}

void Networking_Sockets::InternalSwap(Networking_Sockets* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Networking_Sockets, _impl_.real_port_)
      + sizeof(Networking_Sockets::_impl_.real_port_)
      - PROTOBUF_FIELD_OFFSET(Networking_Sockets, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

std::string Networking_Sockets::GetTypeName() const {
  return "Networking_Sockets";
}


// ===================================================================

class Networking_Messages::_Internal {
 public:
};

Networking_Messages::Networking_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Networking_Messages)
}
Networking_Messages::Networking_Messages(const Networking_Messages& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Networking_Messages* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.id_from_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_from_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.id_from_));
  // @@protoc_insertion_point(copy_constructor:Networking_Messages)
}

inline void Networking_Messages::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.channel_){0u}
    , decltype(_impl_.id_from_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Networking_Messages::~Networking_Messages() {
  // @@protoc_insertion_point(destructor:Networking_Messages)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Networking_Messages::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void Networking_Messages::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Networking_Messages::Clear() {
// @@protoc_insertion_point(message_clear_start:Networking_Messages)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.id_from_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.id_from_));
  _internal_metadata_.Clear<std::string>();
}

const char* Networking_Messages::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Networking_Messages.Types type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Networking_Messages_Types>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 channel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 id_from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.id_from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Networking_Messages::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Networking_Messages)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Networking_Messages.Types type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // uint32 channel = 2;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_channel(), target);
  }

  // uint32 id_from = 3;
  if (this->_internal_id_from() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_id_from(), target);
  }

  // bytes data = 5;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Networking_Messages)
  return target;
}

size_t Networking_Messages::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Networking_Messages)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 5;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // .Networking_Messages.Types type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 channel = 2;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel());
  }

  // uint32 id_from = 3;
  if (this->_internal_id_from() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id_from());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Networking_Messages::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Networking_Messages*>(
      &from));
}

void Networking_Messages::MergeFrom(const Networking_Messages& from) {
  Networking_Messages* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Networking_Messages)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_id_from() != 0) {
    _this->_internal_set_id_from(from._internal_id_from());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Networking_Messages::CopyFrom(const Networking_Messages& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Networking_Messages)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Networking_Messages::IsInitialized() const {
  return true;
}

void Networking_Messages::InternalSwap(Networking_Messages* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Networking_Messages, _impl_.id_from_)
      + sizeof(Networking_Messages::_impl_.id_from_)
      - PROTOBUF_FIELD_OFFSET(Networking_Messages, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

std::string Networking_Messages::GetTypeName() const {
  return "Networking_Messages";
}


// ===================================================================

Gameserver_ValuesEntry_DoNotUse::Gameserver_ValuesEntry_DoNotUse() {}
Gameserver_ValuesEntry_DoNotUse::Gameserver_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Gameserver_ValuesEntry_DoNotUse::MergeFrom(const Gameserver_ValuesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Gameserver::_Internal {
 public:
};

Gameserver::Gameserver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Gameserver)
}
Gameserver::Gameserver(const Gameserver& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Gameserver* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.values_)*/{}
    , decltype(_impl_.game_description_){}
    , decltype(_impl_.mod_dir_){}
    , decltype(_impl_.server_name_){}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.spectator_server_name_){}
    , decltype(_impl_.tags_){}
    , decltype(_impl_.gamedata_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.product_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.max_player_count_){}
    , decltype(_impl_.bot_player_count_){}
    , decltype(_impl_.spectator_port_){}
    , decltype(_impl_.num_players_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.dedicated_server_){}
    , decltype(_impl_.password_protected_){}
    , decltype(_impl_.secure_){}
    , decltype(_impl_.offline_){}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.query_port_){}
    , decltype(_impl_.appid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  _impl_.game_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_game_description().empty()) {
    _this->_impl_.game_description_.Set(from._internal_game_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mod_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mod_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mod_dir().empty()) {
    _this->_impl_.mod_dir_.Set(from._internal_mod_dir(), 
      _this->GetArenaForAllocation());
  }
  _impl_.server_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_server_name().empty()) {
    _this->_impl_.server_name_.Set(from._internal_server_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_map_name().empty()) {
    _this->_impl_.map_name_.Set(from._internal_map_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.spectator_server_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spectator_server_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_spectator_server_name().empty()) {
    _this->_impl_.spectator_server_name_.Set(from._internal_spectator_server_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tags_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tags_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tags().empty()) {
    _this->_impl_.tags_.Set(from._internal_tags(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gamedata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gamedata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_gamedata().empty()) {
    _this->_impl_.gamedata_.Set(from._internal_gamedata(), 
      _this->GetArenaForAllocation());
  }
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_region().empty()) {
    _this->_impl_.region_.Set(from._internal_region(), 
      _this->GetArenaForAllocation());
  }
  _impl_.product_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_product().empty()) {
    _this->_impl_.product_.Set(from._internal_product(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:Gameserver)
}

inline void Gameserver::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.values_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.game_description_){}
    , decltype(_impl_.mod_dir_){}
    , decltype(_impl_.server_name_){}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.spectator_server_name_){}
    , decltype(_impl_.tags_){}
    , decltype(_impl_.gamedata_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.product_){}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.max_player_count_){0u}
    , decltype(_impl_.bot_player_count_){0u}
    , decltype(_impl_.spectator_port_){0u}
    , decltype(_impl_.num_players_){0u}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.dedicated_server_){false}
    , decltype(_impl_.password_protected_){false}
    , decltype(_impl_.secure_){false}
    , decltype(_impl_.offline_){false}
    , decltype(_impl_.ip_){0u}
    , decltype(_impl_.port_){0u}
    , decltype(_impl_.query_port_){0u}
    , decltype(_impl_.appid_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.game_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mod_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mod_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.server_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.spectator_server_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spectator_server_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tags_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tags_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gamedata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gamedata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.product_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Gameserver::~Gameserver() {
  // @@protoc_insertion_point(destructor:Gameserver)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Gameserver::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.values_.Destruct();
  _impl_.values_.~MapFieldLite();
  _impl_.game_description_.Destroy();
  _impl_.mod_dir_.Destroy();
  _impl_.server_name_.Destroy();
  _impl_.map_name_.Destroy();
  _impl_.spectator_server_name_.Destroy();
  _impl_.tags_.Destroy();
  _impl_.gamedata_.Destroy();
  _impl_.region_.Destroy();
  _impl_.product_.Destroy();
}

void Gameserver::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Gameserver::Clear() {
// @@protoc_insertion_point(message_clear_start:Gameserver)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_.Clear();
  _impl_.game_description_.ClearToEmpty();
  _impl_.mod_dir_.ClearToEmpty();
  _impl_.server_name_.ClearToEmpty();
  _impl_.map_name_.ClearToEmpty();
  _impl_.spectator_server_name_.ClearToEmpty();
  _impl_.tags_.ClearToEmpty();
  _impl_.gamedata_.ClearToEmpty();
  _impl_.region_.ClearToEmpty();
  _impl_.product_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.appid_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.appid_));
  _internal_metadata_.Clear<std::string>();
}

const char* Gameserver::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes game_description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_game_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes mod_dir = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_mod_dir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool dedicated_server = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.dedicated_server_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_player_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.max_player_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 bot_player_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.bot_player_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes server_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_server_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes map_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_map_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool password_protected = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.password_protected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 spectator_port = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.spectator_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes spectator_server_name = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_spectator_server_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> values = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.values_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes tags = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_tags();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes gamedata = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_gamedata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes region = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_region();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes product = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_product();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool secure = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.secure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 num_players = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.num_players_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 version = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ip = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 port = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 query_port = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.query_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 appid = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool offline = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.offline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Gameserver::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Gameserver)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // bytes game_description = 2;
  if (!this->_internal_game_description().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_game_description(), target);
  }

  // bytes mod_dir = 3;
  if (!this->_internal_mod_dir().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_mod_dir(), target);
  }

  // bool dedicated_server = 4;
  if (this->_internal_dedicated_server() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_dedicated_server(), target);
  }

  // uint32 max_player_count = 5;
  if (this->_internal_max_player_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_max_player_count(), target);
  }

  // uint32 bot_player_count = 6;
  if (this->_internal_bot_player_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_bot_player_count(), target);
  }

  // bytes server_name = 7;
  if (!this->_internal_server_name().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_server_name(), target);
  }

  // bytes map_name = 8;
  if (!this->_internal_map_name().empty()) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_map_name(), target);
  }

  // bool password_protected = 9;
  if (this->_internal_password_protected() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_password_protected(), target);
  }

  // uint32 spectator_port = 10;
  if (this->_internal_spectator_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_spectator_port(), target);
  }

  // bytes spectator_server_name = 11;
  if (!this->_internal_spectator_server_name().empty()) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_spectator_server_name(), target);
  }

  // map<string, bytes> values = 12;
  if (!this->_internal_values().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Gameserver_ValuesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_values();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "Gameserver.ValuesEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // bytes tags = 13;
  if (!this->_internal_tags().empty()) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_tags(), target);
  }

  // bytes gamedata = 14;
  if (!this->_internal_gamedata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_gamedata(), target);
  }

  // bytes region = 15;
  if (!this->_internal_region().empty()) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_region(), target);
  }

  // bytes product = 16;
  if (!this->_internal_product().empty()) {
    target = stream->WriteBytesMaybeAliased(
        16, this->_internal_product(), target);
  }

  // bool secure = 17;
  if (this->_internal_secure() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_secure(), target);
  }

  // uint32 num_players = 18;
  if (this->_internal_num_players() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_num_players(), target);
  }

  // uint32 version = 19;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_version(), target);
  }

  // uint32 ip = 32;
  if (this->_internal_ip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(32, this->_internal_ip(), target);
  }

  // uint32 port = 33;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(33, this->_internal_port(), target);
  }

  // uint32 query_port = 34;
  if (this->_internal_query_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(34, this->_internal_query_port(), target);
  }

  // uint32 appid = 35;
  if (this->_internal_appid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_appid(), target);
  }

  // bool offline = 48;
  if (this->_internal_offline() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(48, this->_internal_offline(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Gameserver)
  return target;
}

size_t Gameserver::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Gameserver)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> values = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_values_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_values().begin();
      it != this->_internal_values().end(); ++it) {
    total_size += Gameserver_ValuesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // bytes game_description = 2;
  if (!this->_internal_game_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_game_description());
  }

  // bytes mod_dir = 3;
  if (!this->_internal_mod_dir().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mod_dir());
  }

  // bytes server_name = 7;
  if (!this->_internal_server_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_server_name());
  }

  // bytes map_name = 8;
  if (!this->_internal_map_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_map_name());
  }

  // bytes spectator_server_name = 11;
  if (!this->_internal_spectator_server_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_spectator_server_name());
  }

  // bytes tags = 13;
  if (!this->_internal_tags().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tags());
  }

  // bytes gamedata = 14;
  if (!this->_internal_gamedata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_gamedata());
  }

  // bytes region = 15;
  if (!this->_internal_region().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_region());
  }

  // bytes product = 16;
  if (!this->_internal_product().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_product());
  }

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  // uint32 max_player_count = 5;
  if (this->_internal_max_player_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_player_count());
  }

  // uint32 bot_player_count = 6;
  if (this->_internal_bot_player_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bot_player_count());
  }

  // uint32 spectator_port = 10;
  if (this->_internal_spectator_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_spectator_port());
  }

  // uint32 num_players = 18;
  if (this->_internal_num_players() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_num_players());
  }

  // uint32 version = 19;
  if (this->_internal_version() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_version());
  }

  // bool dedicated_server = 4;
  if (this->_internal_dedicated_server() != 0) {
    total_size += 1 + 1;
  }

  // bool password_protected = 9;
  if (this->_internal_password_protected() != 0) {
    total_size += 1 + 1;
  }

  // bool secure = 17;
  if (this->_internal_secure() != 0) {
    total_size += 2 + 1;
  }

  // bool offline = 48;
  if (this->_internal_offline() != 0) {
    total_size += 2 + 1;
  }

  // uint32 ip = 32;
  if (this->_internal_ip() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_ip());
  }

  // uint32 port = 33;
  if (this->_internal_port() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_port());
  }

  // uint32 query_port = 34;
  if (this->_internal_query_port() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_query_port());
  }

  // uint32 appid = 35;
  if (this->_internal_appid() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_appid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Gameserver::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Gameserver*>(
      &from));
}

void Gameserver::MergeFrom(const Gameserver& from) {
  Gameserver* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Gameserver)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  if (!from._internal_game_description().empty()) {
    _this->_internal_set_game_description(from._internal_game_description());
  }
  if (!from._internal_mod_dir().empty()) {
    _this->_internal_set_mod_dir(from._internal_mod_dir());
  }
  if (!from._internal_server_name().empty()) {
    _this->_internal_set_server_name(from._internal_server_name());
  }
  if (!from._internal_map_name().empty()) {
    _this->_internal_set_map_name(from._internal_map_name());
  }
  if (!from._internal_spectator_server_name().empty()) {
    _this->_internal_set_spectator_server_name(from._internal_spectator_server_name());
  }
  if (!from._internal_tags().empty()) {
    _this->_internal_set_tags(from._internal_tags());
  }
  if (!from._internal_gamedata().empty()) {
    _this->_internal_set_gamedata(from._internal_gamedata());
  }
  if (!from._internal_region().empty()) {
    _this->_internal_set_region(from._internal_region());
  }
  if (!from._internal_product().empty()) {
    _this->_internal_set_product(from._internal_product());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_max_player_count() != 0) {
    _this->_internal_set_max_player_count(from._internal_max_player_count());
  }
  if (from._internal_bot_player_count() != 0) {
    _this->_internal_set_bot_player_count(from._internal_bot_player_count());
  }
  if (from._internal_spectator_port() != 0) {
    _this->_internal_set_spectator_port(from._internal_spectator_port());
  }
  if (from._internal_num_players() != 0) {
    _this->_internal_set_num_players(from._internal_num_players());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_dedicated_server() != 0) {
    _this->_internal_set_dedicated_server(from._internal_dedicated_server());
  }
  if (from._internal_password_protected() != 0) {
    _this->_internal_set_password_protected(from._internal_password_protected());
  }
  if (from._internal_secure() != 0) {
    _this->_internal_set_secure(from._internal_secure());
  }
  if (from._internal_offline() != 0) {
    _this->_internal_set_offline(from._internal_offline());
  }
  if (from._internal_ip() != 0) {
    _this->_internal_set_ip(from._internal_ip());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  if (from._internal_query_port() != 0) {
    _this->_internal_set_query_port(from._internal_query_port());
  }
  if (from._internal_appid() != 0) {
    _this->_internal_set_appid(from._internal_appid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Gameserver::CopyFrom(const Gameserver& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Gameserver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Gameserver::IsInitialized() const {
  return true;
}

void Gameserver::InternalSwap(Gameserver* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_description_, lhs_arena,
      &other->_impl_.game_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mod_dir_, lhs_arena,
      &other->_impl_.mod_dir_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.server_name_, lhs_arena,
      &other->_impl_.server_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.map_name_, lhs_arena,
      &other->_impl_.map_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.spectator_server_name_, lhs_arena,
      &other->_impl_.spectator_server_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tags_, lhs_arena,
      &other->_impl_.tags_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gamedata_, lhs_arena,
      &other->_impl_.gamedata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.region_, lhs_arena,
      &other->_impl_.region_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.product_, lhs_arena,
      &other->_impl_.product_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Gameserver, _impl_.appid_)
      + sizeof(Gameserver::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(Gameserver, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string Gameserver::GetTypeName() const {
  return "Gameserver";
}


// ===================================================================

Friend_RichPresenceEntry_DoNotUse::Friend_RichPresenceEntry_DoNotUse() {}
Friend_RichPresenceEntry_DoNotUse::Friend_RichPresenceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Friend_RichPresenceEntry_DoNotUse::MergeFrom(const Friend_RichPresenceEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Friend::_Internal {
 public:
};

Friend::Friend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Friend)
}
Friend::Friend(const Friend& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Friend* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.rich_presence_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.lobby_id_){}
    , decltype(_impl_.appid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.rich_presence_.MergeFrom(from._impl_.rich_presence_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:Friend)
}

inline void Friend::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.rich_presence_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.lobby_id_){uint64_t{0u}}
    , decltype(_impl_.appid_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Friend::~Friend() {
  // @@protoc_insertion_point(destructor:Friend)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Friend::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rich_presence_.Destruct();
  _impl_.rich_presence_.~MapFieldLite();
  _impl_.name_.Destroy();
}

void Friend::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Friend::Clear() {
// @@protoc_insertion_point(message_clear_start:Friend)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rich_presence_.Clear();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.appid_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.appid_));
  _internal_metadata_.Clear<std::string>();
}

const char* Friend::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> rich_presence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.rich_presence_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 appid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 lobby_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.lobby_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Friend::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Friend)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // bytes name = 2;
  if (!this->_internal_name().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_name(), target);
  }

  // map<string, bytes> rich_presence = 3;
  if (!this->_internal_rich_presence().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Friend_RichPresenceEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_rich_presence();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "Friend.RichPresenceEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // uint32 appid = 4;
  if (this->_internal_appid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_appid(), target);
  }

  // uint64 lobby_id = 5;
  if (this->_internal_lobby_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_lobby_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Friend)
  return target;
}

size_t Friend::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Friend)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> rich_presence = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_rich_presence_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_rich_presence().begin();
      it != this->_internal_rich_presence().end(); ++it) {
    total_size += Friend_RichPresenceEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // bytes name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_name());
  }

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  // uint64 lobby_id = 5;
  if (this->_internal_lobby_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_lobby_id());
  }

  // uint32 appid = 4;
  if (this->_internal_appid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Friend::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Friend*>(
      &from));
}

void Friend::MergeFrom(const Friend& from) {
  Friend* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Friend)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.rich_presence_.MergeFrom(from._impl_.rich_presence_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_lobby_id() != 0) {
    _this->_internal_set_lobby_id(from._internal_lobby_id());
  }
  if (from._internal_appid() != 0) {
    _this->_internal_set_appid(from._internal_appid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Friend::CopyFrom(const Friend& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Friend)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Friend::IsInitialized() const {
  return true;
}

void Friend::InternalSwap(Friend* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.rich_presence_.InternalSwap(&other->_impl_.rich_presence_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Friend, _impl_.appid_)
      + sizeof(Friend::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(Friend, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string Friend::GetTypeName() const {
  return "Friend";
}


// ===================================================================

class Auth_Ticket::_Internal {
 public:
};

Auth_Ticket::Auth_Ticket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Auth_Ticket)
}
Auth_Ticket::Auth_Ticket(const Auth_Ticket& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Auth_Ticket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.number_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.number_, &from._impl_.number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.number_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Auth_Ticket)
}

inline void Auth_Ticket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.number_){0u}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Auth_Ticket::~Auth_Ticket() {
  // @@protoc_insertion_point(destructor:Auth_Ticket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Auth_Ticket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Auth_Ticket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Auth_Ticket::Clear() {
// @@protoc_insertion_point(message_clear_start:Auth_Ticket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.number_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.number_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<std::string>();
}

const char* Auth_Ticket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Auth_Ticket.Types type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Auth_Ticket_Types>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Auth_Ticket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Auth_Ticket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 number = 1;
  if (this->_internal_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_number(), target);
  }

  // .Auth_Ticket.Types type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Auth_Ticket)
  return target;
}

size_t Auth_Ticket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Auth_Ticket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 number = 1;
  if (this->_internal_number() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number());
  }

  // .Auth_Ticket.Types type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Auth_Ticket::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Auth_Ticket*>(
      &from));
}

void Auth_Ticket::MergeFrom(const Auth_Ticket& from) {
  Auth_Ticket* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Auth_Ticket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_number() != 0) {
    _this->_internal_set_number(from._internal_number());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Auth_Ticket::CopyFrom(const Auth_Ticket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Auth_Ticket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Auth_Ticket::IsInitialized() const {
  return true;
}

void Auth_Ticket::InternalSwap(Auth_Ticket* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Auth_Ticket, _impl_.type_)
      + sizeof(Auth_Ticket::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(Auth_Ticket, _impl_.number_)>(
          reinterpret_cast<char*>(&_impl_.number_),
          reinterpret_cast<char*>(&other->_impl_.number_));
}

std::string Auth_Ticket::GetTypeName() const {
  return "Auth_Ticket";
}


// ===================================================================

class Friend_Messages::_Internal {
 public:
};

Friend_Messages::Friend_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Friend_Messages)
}
Friend_Messages::Friend_Messages(const Friend_Messages& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Friend_Messages* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.invite_data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  clear_has_invite_data();
  switch (from.invite_data_case()) {
    case kLobbyId: {
      _this->_internal_set_lobby_id(from._internal_lobby_id());
      break;
    }
    case kConnectStr: {
      _this->_internal_set_connect_str(from._internal_connect_str());
      break;
    }
    case INVITE_DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Friend_Messages)
}

inline void Friend_Messages::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){0}
    , decltype(_impl_.invite_data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_invite_data();
}

Friend_Messages::~Friend_Messages() {
  // @@protoc_insertion_point(destructor:Friend_Messages)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Friend_Messages::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_invite_data()) {
    clear_invite_data();
  }
}

void Friend_Messages::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Friend_Messages::clear_invite_data() {
// @@protoc_insertion_point(one_of_clear_start:Friend_Messages)
  switch (invite_data_case()) {
    case kLobbyId: {
      // No need to clear
      break;
    }
    case kConnectStr: {
      _impl_.invite_data_.connect_str_.Destroy();
      break;
    }
    case INVITE_DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = INVITE_DATA_NOT_SET;
}


void Friend_Messages::Clear() {
// @@protoc_insertion_point(message_clear_start:Friend_Messages)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  clear_invite_data();
  _internal_metadata_.Clear<std::string>();
}

const char* Friend_Messages::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Friend_Messages.Types type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Friend_Messages_Types>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 lobby_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_lobby_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes connect_str = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_connect_str();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Friend_Messages::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Friend_Messages)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Friend_Messages.Types type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // uint64 lobby_id = 2;
  if (_internal_has_lobby_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_lobby_id(), target);
  }

  // bytes connect_str = 3;
  if (_internal_has_connect_str()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_connect_str(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Friend_Messages)
  return target;
}

size_t Friend_Messages::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Friend_Messages)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Friend_Messages.Types type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  switch (invite_data_case()) {
    // uint64 lobby_id = 2;
    case kLobbyId: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_lobby_id());
      break;
    }
    // bytes connect_str = 3;
    case kConnectStr: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_connect_str());
      break;
    }
    case INVITE_DATA_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Friend_Messages::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Friend_Messages*>(
      &from));
}

void Friend_Messages::MergeFrom(const Friend_Messages& from) {
  Friend_Messages* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Friend_Messages)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  switch (from.invite_data_case()) {
    case kLobbyId: {
      _this->_internal_set_lobby_id(from._internal_lobby_id());
      break;
    }
    case kConnectStr: {
      _this->_internal_set_connect_str(from._internal_connect_str());
      break;
    }
    case INVITE_DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Friend_Messages::CopyFrom(const Friend_Messages& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Friend_Messages)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Friend_Messages::IsInitialized() const {
  return true;
}

void Friend_Messages::InternalSwap(Friend_Messages* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_.invite_data_, other->_impl_.invite_data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string Friend_Messages::GetTypeName() const {
  return "Friend_Messages";
}


// ===================================================================

class Steam_Messages::_Internal {
 public:
};

Steam_Messages::Steam_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Steam_Messages)
}
Steam_Messages::Steam_Messages(const Steam_Messages& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Steam_Messages* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.message_data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  clear_has_message_data();
  switch (from.message_data_case()) {
    case kMessage: {
      _this->_internal_set_message(from._internal_message());
      break;
    }
    case MESSAGE_DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Steam_Messages)
}

inline void Steam_Messages::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){0}
    , decltype(_impl_.message_data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message_data();
}

Steam_Messages::~Steam_Messages() {
  // @@protoc_insertion_point(destructor:Steam_Messages)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Steam_Messages::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message_data()) {
    clear_message_data();
  }
}

void Steam_Messages::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Steam_Messages::clear_message_data() {
// @@protoc_insertion_point(one_of_clear_start:Steam_Messages)
  switch (message_data_case()) {
    case kMessage: {
      _impl_.message_data_.message_.Destroy();
      break;
    }
    case MESSAGE_DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_DATA_NOT_SET;
}


void Steam_Messages::Clear() {
// @@protoc_insertion_point(message_clear_start:Steam_Messages)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  clear_message_data();
  _internal_metadata_.Clear<std::string>();
}

const char* Steam_Messages::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Steam_Messages.Types type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Steam_Messages_Types>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Steam_Messages::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Steam_Messages)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Steam_Messages.Types type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // bytes message = 2;
  if (_internal_has_message()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Steam_Messages)
  return target;
}

size_t Steam_Messages::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Steam_Messages)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Steam_Messages.Types type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  switch (message_data_case()) {
    // bytes message = 2;
    case kMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
      break;
    }
    case MESSAGE_DATA_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Steam_Messages::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Steam_Messages*>(
      &from));
}

void Steam_Messages::MergeFrom(const Steam_Messages& from) {
  Steam_Messages* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Steam_Messages)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  switch (from.message_data_case()) {
    case kMessage: {
      _this->_internal_set_message(from._internal_message());
      break;
    }
    case MESSAGE_DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Steam_Messages::CopyFrom(const Steam_Messages& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Steam_Messages)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Steam_Messages::IsInitialized() const {
  return true;
}

void Steam_Messages::InternalSwap(Steam_Messages* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_.message_data_, other->_impl_.message_data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string Steam_Messages::GetTypeName() const {
  return "Steam_Messages";
}


// ===================================================================

class Common_Message::_Internal {
 public:
  static const ::Announce& announce(const Common_Message* msg);
  static const ::Low_Level& low_level(const Common_Message* msg);
  static const ::Lobby& lobby(const Common_Message* msg);
  static const ::Lobby_Messages& lobby_messages(const Common_Message* msg);
  static const ::Network_pb& network(const Common_Message* msg);
  static const ::Gameserver& gameserver(const Common_Message* msg);
  static const ::Friend& friend_(const Common_Message* msg);
  static const ::Auth_Ticket& auth_ticket(const Common_Message* msg);
  static const ::Friend_Messages& friend_messages(const Common_Message* msg);
  static const ::Network_Old& network_old(const Common_Message* msg);
  static const ::Networking_Sockets& networking_sockets(const Common_Message* msg);
  static const ::Steam_Messages& steam_messages(const Common_Message* msg);
  static const ::Networking_Messages& networking_messages(const Common_Message* msg);
};

const ::Announce&
Common_Message::_Internal::announce(const Common_Message* msg) {
  return *msg->_impl_.messages_.announce_;
}
const ::Low_Level&
Common_Message::_Internal::low_level(const Common_Message* msg) {
  return *msg->_impl_.messages_.low_level_;
}
const ::Lobby&
Common_Message::_Internal::lobby(const Common_Message* msg) {
  return *msg->_impl_.messages_.lobby_;
}
const ::Lobby_Messages&
Common_Message::_Internal::lobby_messages(const Common_Message* msg) {
  return *msg->_impl_.messages_.lobby_messages_;
}
const ::Network_pb&
Common_Message::_Internal::network(const Common_Message* msg) {
  return *msg->_impl_.messages_.network_;
}
const ::Gameserver&
Common_Message::_Internal::gameserver(const Common_Message* msg) {
  return *msg->_impl_.messages_.gameserver_;
}
const ::Friend&
Common_Message::_Internal::friend_(const Common_Message* msg) {
  return *msg->_impl_.messages_.friend__;
}
const ::Auth_Ticket&
Common_Message::_Internal::auth_ticket(const Common_Message* msg) {
  return *msg->_impl_.messages_.auth_ticket_;
}
const ::Friend_Messages&
Common_Message::_Internal::friend_messages(const Common_Message* msg) {
  return *msg->_impl_.messages_.friend_messages_;
}
const ::Network_Old&
Common_Message::_Internal::network_old(const Common_Message* msg) {
  return *msg->_impl_.messages_.network_old_;
}
const ::Networking_Sockets&
Common_Message::_Internal::networking_sockets(const Common_Message* msg) {
  return *msg->_impl_.messages_.networking_sockets_;
}
const ::Steam_Messages&
Common_Message::_Internal::steam_messages(const Common_Message* msg) {
  return *msg->_impl_.messages_.steam_messages_;
}
const ::Networking_Messages&
Common_Message::_Internal::networking_messages(const Common_Message* msg) {
  return *msg->_impl_.messages_.networking_messages_;
}
void Common_Message::set_allocated_announce(::Announce* announce) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (announce) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(announce);
    if (message_arena != submessage_arena) {
      announce = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, announce, submessage_arena);
    }
    set_has_announce();
    _impl_.messages_.announce_ = announce;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.announce)
}
void Common_Message::set_allocated_low_level(::Low_Level* low_level) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (low_level) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(low_level);
    if (message_arena != submessage_arena) {
      low_level = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low_level, submessage_arena);
    }
    set_has_low_level();
    _impl_.messages_.low_level_ = low_level;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.low_level)
}
void Common_Message::set_allocated_lobby(::Lobby* lobby) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (lobby) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lobby);
    if (message_arena != submessage_arena) {
      lobby = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lobby, submessage_arena);
    }
    set_has_lobby();
    _impl_.messages_.lobby_ = lobby;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.lobby)
}
void Common_Message::set_allocated_lobby_messages(::Lobby_Messages* lobby_messages) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (lobby_messages) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lobby_messages);
    if (message_arena != submessage_arena) {
      lobby_messages = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lobby_messages, submessage_arena);
    }
    set_has_lobby_messages();
    _impl_.messages_.lobby_messages_ = lobby_messages;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.lobby_messages)
}
void Common_Message::set_allocated_network(::Network_pb* network) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (network) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network);
    if (message_arena != submessage_arena) {
      network = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network, submessage_arena);
    }
    set_has_network();
    _impl_.messages_.network_ = network;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.network)
}
void Common_Message::set_allocated_gameserver(::Gameserver* gameserver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (gameserver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gameserver);
    if (message_arena != submessage_arena) {
      gameserver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameserver, submessage_arena);
    }
    set_has_gameserver();
    _impl_.messages_.gameserver_ = gameserver;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.gameserver)
}
void Common_Message::set_allocated_friend_(::Friend* friend_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (friend_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_);
    if (message_arena != submessage_arena) {
      friend_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_, submessage_arena);
    }
    set_has_friend_();
    _impl_.messages_.friend__ = friend_;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.friend)
}
void Common_Message::set_allocated_auth_ticket(::Auth_Ticket* auth_ticket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (auth_ticket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth_ticket);
    if (message_arena != submessage_arena) {
      auth_ticket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth_ticket, submessage_arena);
    }
    set_has_auth_ticket();
    _impl_.messages_.auth_ticket_ = auth_ticket;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.auth_ticket)
}
void Common_Message::set_allocated_friend_messages(::Friend_Messages* friend_messages) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (friend_messages) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_messages);
    if (message_arena != submessage_arena) {
      friend_messages = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_messages, submessage_arena);
    }
    set_has_friend_messages();
    _impl_.messages_.friend_messages_ = friend_messages;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.friend_messages)
}
void Common_Message::set_allocated_network_old(::Network_Old* network_old) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (network_old) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network_old);
    if (message_arena != submessage_arena) {
      network_old = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_old, submessage_arena);
    }
    set_has_network_old();
    _impl_.messages_.network_old_ = network_old;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.network_old)
}
void Common_Message::set_allocated_networking_sockets(::Networking_Sockets* networking_sockets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (networking_sockets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(networking_sockets);
    if (message_arena != submessage_arena) {
      networking_sockets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, networking_sockets, submessage_arena);
    }
    set_has_networking_sockets();
    _impl_.messages_.networking_sockets_ = networking_sockets;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.networking_sockets)
}
void Common_Message::set_allocated_steam_messages(::Steam_Messages* steam_messages) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (steam_messages) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(steam_messages);
    if (message_arena != submessage_arena) {
      steam_messages = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steam_messages, submessage_arena);
    }
    set_has_steam_messages();
    _impl_.messages_.steam_messages_ = steam_messages;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.steam_messages)
}
void Common_Message::set_allocated_networking_messages(::Networking_Messages* networking_messages) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_messages();
  if (networking_messages) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(networking_messages);
    if (message_arena != submessage_arena) {
      networking_messages = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, networking_messages, submessage_arena);
    }
    set_has_networking_messages();
    _impl_.messages_.networking_messages_ = networking_messages;
  }
  // @@protoc_insertion_point(field_set_allocated:Common_Message.networking_messages)
}
Common_Message::Common_Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Common_Message)
}
Common_Message::Common_Message(const Common_Message& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Common_Message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_id_){}
    , decltype(_impl_.dest_id_){}
    , decltype(_impl_.source_ip_){}
    , decltype(_impl_.source_port_){}
    , decltype(_impl_.messages_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.source_id_, &from._impl_.source_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.source_port_) -
    reinterpret_cast<char*>(&_impl_.source_id_)) + sizeof(_impl_.source_port_));
  clear_has_messages();
  switch (from.messages_case()) {
    case kAnnounce: {
      _this->_internal_mutable_announce()->::Announce::MergeFrom(
          from._internal_announce());
      break;
    }
    case kLowLevel: {
      _this->_internal_mutable_low_level()->::Low_Level::MergeFrom(
          from._internal_low_level());
      break;
    }
    case kLobby: {
      _this->_internal_mutable_lobby()->::Lobby::MergeFrom(
          from._internal_lobby());
      break;
    }
    case kLobbyMessages: {
      _this->_internal_mutable_lobby_messages()->::Lobby_Messages::MergeFrom(
          from._internal_lobby_messages());
      break;
    }
    case kNetwork: {
      _this->_internal_mutable_network()->::Network_pb::MergeFrom(
          from._internal_network());
      break;
    }
    case kGameserver: {
      _this->_internal_mutable_gameserver()->::Gameserver::MergeFrom(
          from._internal_gameserver());
      break;
    }
    case kFriend: {
      _this->_internal_mutable_friend_()->::Friend::MergeFrom(
          from._internal_friend_());
      break;
    }
    case kAuthTicket: {
      _this->_internal_mutable_auth_ticket()->::Auth_Ticket::MergeFrom(
          from._internal_auth_ticket());
      break;
    }
    case kFriendMessages: {
      _this->_internal_mutable_friend_messages()->::Friend_Messages::MergeFrom(
          from._internal_friend_messages());
      break;
    }
    case kNetworkOld: {
      _this->_internal_mutable_network_old()->::Network_Old::MergeFrom(
          from._internal_network_old());
      break;
    }
    case kNetworkingSockets: {
      _this->_internal_mutable_networking_sockets()->::Networking_Sockets::MergeFrom(
          from._internal_networking_sockets());
      break;
    }
    case kSteamMessages: {
      _this->_internal_mutable_steam_messages()->::Steam_Messages::MergeFrom(
          from._internal_steam_messages());
      break;
    }
    case kNetworkingMessages: {
      _this->_internal_mutable_networking_messages()->::Networking_Messages::MergeFrom(
          from._internal_networking_messages());
      break;
    }
    case MESSAGES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Common_Message)
}

inline void Common_Message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_id_){uint64_t{0u}}
    , decltype(_impl_.dest_id_){uint64_t{0u}}
    , decltype(_impl_.source_ip_){0u}
    , decltype(_impl_.source_port_){0u}
    , decltype(_impl_.messages_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_messages();
}

Common_Message::~Common_Message() {
  // @@protoc_insertion_point(destructor:Common_Message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Common_Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_messages()) {
    clear_messages();
  }
}

void Common_Message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Common_Message::clear_messages() {
// @@protoc_insertion_point(one_of_clear_start:Common_Message)
  switch (messages_case()) {
    case kAnnounce: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.announce_;
      }
      break;
    }
    case kLowLevel: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.low_level_;
      }
      break;
    }
    case kLobby: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.lobby_;
      }
      break;
    }
    case kLobbyMessages: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.lobby_messages_;
      }
      break;
    }
    case kNetwork: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.network_;
      }
      break;
    }
    case kGameserver: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.gameserver_;
      }
      break;
    }
    case kFriend: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.friend__;
      }
      break;
    }
    case kAuthTicket: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.auth_ticket_;
      }
      break;
    }
    case kFriendMessages: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.friend_messages_;
      }
      break;
    }
    case kNetworkOld: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.network_old_;
      }
      break;
    }
    case kNetworkingSockets: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.networking_sockets_;
      }
      break;
    }
    case kSteamMessages: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.steam_messages_;
      }
      break;
    }
    case kNetworkingMessages: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.messages_.networking_messages_;
      }
      break;
    }
    case MESSAGES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGES_NOT_SET;
}


void Common_Message::Clear() {
// @@protoc_insertion_point(message_clear_start:Common_Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.source_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.source_port_) -
      reinterpret_cast<char*>(&_impl_.source_id_)) + sizeof(_impl_.source_port_));
  clear_messages();
  _internal_metadata_.Clear<std::string>();
}

const char* Common_Message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 source_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.source_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 dest_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.dest_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Announce announce = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_announce(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Low_Level low_level = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_low_level(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Lobby lobby = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_lobby(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Lobby_Messages lobby_messages = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_lobby_messages(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Network_pb network = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_network(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Gameserver gameserver = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameserver(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Friend friend = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_friend_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Auth_Ticket auth_ticket = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_auth_ticket(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Friend_Messages friend_messages = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_friend_messages(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Network_Old network_old = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_network_old(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Networking_Sockets networking_sockets = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_networking_sockets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Steam_Messages steam_messages = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_steam_messages(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Networking_Messages networking_messages = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_networking_messages(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 source_ip = 128;
      case 128:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _impl_.source_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 source_port = 129;
      case 129:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.source_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Common_Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Common_Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 source_id = 1;
  if (this->_internal_source_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_source_id(), target);
  }

  // uint64 dest_id = 2;
  if (this->_internal_dest_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_dest_id(), target);
  }

  // .Announce announce = 3;
  if (_internal_has_announce()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::announce(this),
        _Internal::announce(this).GetCachedSize(), target, stream);
  }

  // .Low_Level low_level = 4;
  if (_internal_has_low_level()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::low_level(this),
        _Internal::low_level(this).GetCachedSize(), target, stream);
  }

  // .Lobby lobby = 5;
  if (_internal_has_lobby()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::lobby(this),
        _Internal::lobby(this).GetCachedSize(), target, stream);
  }

  // .Lobby_Messages lobby_messages = 6;
  if (_internal_has_lobby_messages()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::lobby_messages(this),
        _Internal::lobby_messages(this).GetCachedSize(), target, stream);
  }

  // .Network_pb network = 7;
  if (_internal_has_network()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::network(this),
        _Internal::network(this).GetCachedSize(), target, stream);
  }

  // .Gameserver gameserver = 8;
  if (_internal_has_gameserver()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::gameserver(this),
        _Internal::gameserver(this).GetCachedSize(), target, stream);
  }

  // .Friend friend = 9;
  if (_internal_has_friend_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::friend_(this),
        _Internal::friend_(this).GetCachedSize(), target, stream);
  }

  // .Auth_Ticket auth_ticket = 10;
  if (_internal_has_auth_ticket()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::auth_ticket(this),
        _Internal::auth_ticket(this).GetCachedSize(), target, stream);
  }

  // .Friend_Messages friend_messages = 11;
  if (_internal_has_friend_messages()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::friend_messages(this),
        _Internal::friend_messages(this).GetCachedSize(), target, stream);
  }

  // .Network_Old network_old = 12;
  if (_internal_has_network_old()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::network_old(this),
        _Internal::network_old(this).GetCachedSize(), target, stream);
  }

  // .Networking_Sockets networking_sockets = 13;
  if (_internal_has_networking_sockets()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::networking_sockets(this),
        _Internal::networking_sockets(this).GetCachedSize(), target, stream);
  }

  // .Steam_Messages steam_messages = 14;
  if (_internal_has_steam_messages()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::steam_messages(this),
        _Internal::steam_messages(this).GetCachedSize(), target, stream);
  }

  // .Networking_Messages networking_messages = 15;
  if (_internal_has_networking_messages()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::networking_messages(this),
        _Internal::networking_messages(this).GetCachedSize(), target, stream);
  }

  // uint32 source_ip = 128;
  if (this->_internal_source_ip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(128, this->_internal_source_ip(), target);
  }

  // uint32 source_port = 129;
  if (this->_internal_source_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(129, this->_internal_source_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Common_Message)
  return target;
}

size_t Common_Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Common_Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 source_id = 1;
  if (this->_internal_source_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_source_id());
  }

  // uint64 dest_id = 2;
  if (this->_internal_dest_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dest_id());
  }

  // uint32 source_ip = 128;
  if (this->_internal_source_ip() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_source_ip());
  }

  // uint32 source_port = 129;
  if (this->_internal_source_port() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_source_port());
  }

  switch (messages_case()) {
    // .Announce announce = 3;
    case kAnnounce: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.announce_);
      break;
    }
    // .Low_Level low_level = 4;
    case kLowLevel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.low_level_);
      break;
    }
    // .Lobby lobby = 5;
    case kLobby: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.lobby_);
      break;
    }
    // .Lobby_Messages lobby_messages = 6;
    case kLobbyMessages: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.lobby_messages_);
      break;
    }
    // .Network_pb network = 7;
    case kNetwork: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.network_);
      break;
    }
    // .Gameserver gameserver = 8;
    case kGameserver: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.gameserver_);
      break;
    }
    // .Friend friend = 9;
    case kFriend: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.friend__);
      break;
    }
    // .Auth_Ticket auth_ticket = 10;
    case kAuthTicket: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.auth_ticket_);
      break;
    }
    // .Friend_Messages friend_messages = 11;
    case kFriendMessages: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.friend_messages_);
      break;
    }
    // .Network_Old network_old = 12;
    case kNetworkOld: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.network_old_);
      break;
    }
    // .Networking_Sockets networking_sockets = 13;
    case kNetworkingSockets: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.networking_sockets_);
      break;
    }
    // .Steam_Messages steam_messages = 14;
    case kSteamMessages: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.steam_messages_);
      break;
    }
    // .Networking_Messages networking_messages = 15;
    case kNetworkingMessages: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.messages_.networking_messages_);
      break;
    }
    case MESSAGES_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Common_Message::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Common_Message*>(
      &from));
}

void Common_Message::MergeFrom(const Common_Message& from) {
  Common_Message* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Common_Message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_source_id() != 0) {
    _this->_internal_set_source_id(from._internal_source_id());
  }
  if (from._internal_dest_id() != 0) {
    _this->_internal_set_dest_id(from._internal_dest_id());
  }
  if (from._internal_source_ip() != 0) {
    _this->_internal_set_source_ip(from._internal_source_ip());
  }
  if (from._internal_source_port() != 0) {
    _this->_internal_set_source_port(from._internal_source_port());
  }
  switch (from.messages_case()) {
    case kAnnounce: {
      _this->_internal_mutable_announce()->::Announce::MergeFrom(
          from._internal_announce());
      break;
    }
    case kLowLevel: {
      _this->_internal_mutable_low_level()->::Low_Level::MergeFrom(
          from._internal_low_level());
      break;
    }
    case kLobby: {
      _this->_internal_mutable_lobby()->::Lobby::MergeFrom(
          from._internal_lobby());
      break;
    }
    case kLobbyMessages: {
      _this->_internal_mutable_lobby_messages()->::Lobby_Messages::MergeFrom(
          from._internal_lobby_messages());
      break;
    }
    case kNetwork: {
      _this->_internal_mutable_network()->::Network_pb::MergeFrom(
          from._internal_network());
      break;
    }
    case kGameserver: {
      _this->_internal_mutable_gameserver()->::Gameserver::MergeFrom(
          from._internal_gameserver());
      break;
    }
    case kFriend: {
      _this->_internal_mutable_friend_()->::Friend::MergeFrom(
          from._internal_friend_());
      break;
    }
    case kAuthTicket: {
      _this->_internal_mutable_auth_ticket()->::Auth_Ticket::MergeFrom(
          from._internal_auth_ticket());
      break;
    }
    case kFriendMessages: {
      _this->_internal_mutable_friend_messages()->::Friend_Messages::MergeFrom(
          from._internal_friend_messages());
      break;
    }
    case kNetworkOld: {
      _this->_internal_mutable_network_old()->::Network_Old::MergeFrom(
          from._internal_network_old());
      break;
    }
    case kNetworkingSockets: {
      _this->_internal_mutable_networking_sockets()->::Networking_Sockets::MergeFrom(
          from._internal_networking_sockets());
      break;
    }
    case kSteamMessages: {
      _this->_internal_mutable_steam_messages()->::Steam_Messages::MergeFrom(
          from._internal_steam_messages());
      break;
    }
    case kNetworkingMessages: {
      _this->_internal_mutable_networking_messages()->::Networking_Messages::MergeFrom(
          from._internal_networking_messages());
      break;
    }
    case MESSAGES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Common_Message::CopyFrom(const Common_Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Common_Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Common_Message::IsInitialized() const {
  return true;
}

void Common_Message::InternalSwap(Common_Message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Common_Message, _impl_.source_port_)
      + sizeof(Common_Message::_impl_.source_port_)
      - PROTOBUF_FIELD_OFFSET(Common_Message, _impl_.source_id_)>(
          reinterpret_cast<char*>(&_impl_.source_id_),
          reinterpret_cast<char*>(&other->_impl_.source_id_));
  swap(_impl_.messages_, other->_impl_.messages_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string Common_Message::GetTypeName() const {
  return "Common_Message";
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Announce_Other_Peers*
Arena::CreateMaybeMessage< ::Announce_Other_Peers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Announce_Other_Peers >(arena);
}
template<> PROTOBUF_NOINLINE ::Announce*
Arena::CreateMaybeMessage< ::Announce >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Announce >(arena);
}
template<> PROTOBUF_NOINLINE ::Lobby_ValuesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::Lobby_ValuesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Lobby_ValuesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::Lobby_Member_ValuesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::Lobby_Member_ValuesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Lobby_Member_ValuesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::Lobby_Member*
Arena::CreateMaybeMessage< ::Lobby_Member >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Lobby_Member >(arena);
}
template<> PROTOBUF_NOINLINE ::Lobby_Gameserver*
Arena::CreateMaybeMessage< ::Lobby_Gameserver >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Lobby_Gameserver >(arena);
}
template<> PROTOBUF_NOINLINE ::Lobby*
Arena::CreateMaybeMessage< ::Lobby >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Lobby >(arena);
}
template<> PROTOBUF_NOINLINE ::Lobby_Messages_MapEntry_DoNotUse*
Arena::CreateMaybeMessage< ::Lobby_Messages_MapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Lobby_Messages_MapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::Lobby_Messages*
Arena::CreateMaybeMessage< ::Lobby_Messages >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Lobby_Messages >(arena);
}
template<> PROTOBUF_NOINLINE ::Low_Level*
Arena::CreateMaybeMessage< ::Low_Level >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Low_Level >(arena);
}
template<> PROTOBUF_NOINLINE ::Network_pb*
Arena::CreateMaybeMessage< ::Network_pb >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Network_pb >(arena);
}
template<> PROTOBUF_NOINLINE ::Network_Old*
Arena::CreateMaybeMessage< ::Network_Old >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Network_Old >(arena);
}
template<> PROTOBUF_NOINLINE ::Networking_Sockets*
Arena::CreateMaybeMessage< ::Networking_Sockets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Networking_Sockets >(arena);
}
template<> PROTOBUF_NOINLINE ::Networking_Messages*
Arena::CreateMaybeMessage< ::Networking_Messages >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Networking_Messages >(arena);
}
template<> PROTOBUF_NOINLINE ::Gameserver_ValuesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::Gameserver_ValuesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Gameserver_ValuesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::Gameserver*
Arena::CreateMaybeMessage< ::Gameserver >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Gameserver >(arena);
}
template<> PROTOBUF_NOINLINE ::Friend_RichPresenceEntry_DoNotUse*
Arena::CreateMaybeMessage< ::Friend_RichPresenceEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Friend_RichPresenceEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::Friend*
Arena::CreateMaybeMessage< ::Friend >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Friend >(arena);
}
template<> PROTOBUF_NOINLINE ::Auth_Ticket*
Arena::CreateMaybeMessage< ::Auth_Ticket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Auth_Ticket >(arena);
}
template<> PROTOBUF_NOINLINE ::Friend_Messages*
Arena::CreateMaybeMessage< ::Friend_Messages >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Friend_Messages >(arena);
}
template<> PROTOBUF_NOINLINE ::Steam_Messages*
Arena::CreateMaybeMessage< ::Steam_Messages >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Steam_Messages >(arena);
}
template<> PROTOBUF_NOINLINE ::Common_Message*
Arena::CreateMaybeMessage< ::Common_Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Common_Message >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
