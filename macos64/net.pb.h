// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_net_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_net_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_net_2eproto {
  static const uint32_t offsets[];
};
class Announce;
struct AnnounceDefaultTypeInternal;
extern AnnounceDefaultTypeInternal _Announce_default_instance_;
class Announce_Other_Peers;
struct Announce_Other_PeersDefaultTypeInternal;
extern Announce_Other_PeersDefaultTypeInternal _Announce_Other_Peers_default_instance_;
class Auth_Ticket;
struct Auth_TicketDefaultTypeInternal;
extern Auth_TicketDefaultTypeInternal _Auth_Ticket_default_instance_;
class Common_Message;
struct Common_MessageDefaultTypeInternal;
extern Common_MessageDefaultTypeInternal _Common_Message_default_instance_;
class Friend;
struct FriendDefaultTypeInternal;
extern FriendDefaultTypeInternal _Friend_default_instance_;
class Friend_Messages;
struct Friend_MessagesDefaultTypeInternal;
extern Friend_MessagesDefaultTypeInternal _Friend_Messages_default_instance_;
class Friend_RichPresenceEntry_DoNotUse;
struct Friend_RichPresenceEntry_DoNotUseDefaultTypeInternal;
extern Friend_RichPresenceEntry_DoNotUseDefaultTypeInternal _Friend_RichPresenceEntry_DoNotUse_default_instance_;
class Gameserver;
struct GameserverDefaultTypeInternal;
extern GameserverDefaultTypeInternal _Gameserver_default_instance_;
class Gameserver_ValuesEntry_DoNotUse;
struct Gameserver_ValuesEntry_DoNotUseDefaultTypeInternal;
extern Gameserver_ValuesEntry_DoNotUseDefaultTypeInternal _Gameserver_ValuesEntry_DoNotUse_default_instance_;
class Lobby;
struct LobbyDefaultTypeInternal;
extern LobbyDefaultTypeInternal _Lobby_default_instance_;
class Lobby_Gameserver;
struct Lobby_GameserverDefaultTypeInternal;
extern Lobby_GameserverDefaultTypeInternal _Lobby_Gameserver_default_instance_;
class Lobby_Member;
struct Lobby_MemberDefaultTypeInternal;
extern Lobby_MemberDefaultTypeInternal _Lobby_Member_default_instance_;
class Lobby_Member_ValuesEntry_DoNotUse;
struct Lobby_Member_ValuesEntry_DoNotUseDefaultTypeInternal;
extern Lobby_Member_ValuesEntry_DoNotUseDefaultTypeInternal _Lobby_Member_ValuesEntry_DoNotUse_default_instance_;
class Lobby_Messages;
struct Lobby_MessagesDefaultTypeInternal;
extern Lobby_MessagesDefaultTypeInternal _Lobby_Messages_default_instance_;
class Lobby_Messages_MapEntry_DoNotUse;
struct Lobby_Messages_MapEntry_DoNotUseDefaultTypeInternal;
extern Lobby_Messages_MapEntry_DoNotUseDefaultTypeInternal _Lobby_Messages_MapEntry_DoNotUse_default_instance_;
class Lobby_ValuesEntry_DoNotUse;
struct Lobby_ValuesEntry_DoNotUseDefaultTypeInternal;
extern Lobby_ValuesEntry_DoNotUseDefaultTypeInternal _Lobby_ValuesEntry_DoNotUse_default_instance_;
class Low_Level;
struct Low_LevelDefaultTypeInternal;
extern Low_LevelDefaultTypeInternal _Low_Level_default_instance_;
class Network_Old;
struct Network_OldDefaultTypeInternal;
extern Network_OldDefaultTypeInternal _Network_Old_default_instance_;
class Network_pb;
struct Network_pbDefaultTypeInternal;
extern Network_pbDefaultTypeInternal _Network_pb_default_instance_;
class Networking_Messages;
struct Networking_MessagesDefaultTypeInternal;
extern Networking_MessagesDefaultTypeInternal _Networking_Messages_default_instance_;
class Networking_Sockets;
struct Networking_SocketsDefaultTypeInternal;
extern Networking_SocketsDefaultTypeInternal _Networking_Sockets_default_instance_;
class Steam_Messages;
struct Steam_MessagesDefaultTypeInternal;
extern Steam_MessagesDefaultTypeInternal _Steam_Messages_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Announce* Arena::CreateMaybeMessage<::Announce>(Arena*);
template<> ::Announce_Other_Peers* Arena::CreateMaybeMessage<::Announce_Other_Peers>(Arena*);
template<> ::Auth_Ticket* Arena::CreateMaybeMessage<::Auth_Ticket>(Arena*);
template<> ::Common_Message* Arena::CreateMaybeMessage<::Common_Message>(Arena*);
template<> ::Friend* Arena::CreateMaybeMessage<::Friend>(Arena*);
template<> ::Friend_Messages* Arena::CreateMaybeMessage<::Friend_Messages>(Arena*);
template<> ::Friend_RichPresenceEntry_DoNotUse* Arena::CreateMaybeMessage<::Friend_RichPresenceEntry_DoNotUse>(Arena*);
template<> ::Gameserver* Arena::CreateMaybeMessage<::Gameserver>(Arena*);
template<> ::Gameserver_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::Gameserver_ValuesEntry_DoNotUse>(Arena*);
template<> ::Lobby* Arena::CreateMaybeMessage<::Lobby>(Arena*);
template<> ::Lobby_Gameserver* Arena::CreateMaybeMessage<::Lobby_Gameserver>(Arena*);
template<> ::Lobby_Member* Arena::CreateMaybeMessage<::Lobby_Member>(Arena*);
template<> ::Lobby_Member_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::Lobby_Member_ValuesEntry_DoNotUse>(Arena*);
template<> ::Lobby_Messages* Arena::CreateMaybeMessage<::Lobby_Messages>(Arena*);
template<> ::Lobby_Messages_MapEntry_DoNotUse* Arena::CreateMaybeMessage<::Lobby_Messages_MapEntry_DoNotUse>(Arena*);
template<> ::Lobby_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::Lobby_ValuesEntry_DoNotUse>(Arena*);
template<> ::Low_Level* Arena::CreateMaybeMessage<::Low_Level>(Arena*);
template<> ::Network_Old* Arena::CreateMaybeMessage<::Network_Old>(Arena*);
template<> ::Network_pb* Arena::CreateMaybeMessage<::Network_pb>(Arena*);
template<> ::Networking_Messages* Arena::CreateMaybeMessage<::Networking_Messages>(Arena*);
template<> ::Networking_Sockets* Arena::CreateMaybeMessage<::Networking_Sockets>(Arena*);
template<> ::Steam_Messages* Arena::CreateMaybeMessage<::Steam_Messages>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Announce_Types : int {
  Announce_Types_PING = 0,
  Announce_Types_PONG = 1,
  Announce_Types_Announce_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Announce_Types_Announce_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Announce_Types_IsValid(int value);
constexpr Announce_Types Announce_Types_Types_MIN = Announce_Types_PING;
constexpr Announce_Types Announce_Types_Types_MAX = Announce_Types_PONG;
constexpr int Announce_Types_Types_ARRAYSIZE = Announce_Types_Types_MAX + 1;

const std::string& Announce_Types_Name(Announce_Types value);
template<typename T>
inline const std::string& Announce_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Announce_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Announce_Types_Name.");
  return Announce_Types_Name(static_cast<Announce_Types>(enum_t_value));
}
bool Announce_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Announce_Types* value);
enum Lobby_Messages_Types : int {
  Lobby_Messages_Types_JOIN = 0,
  Lobby_Messages_Types_LEAVE = 1,
  Lobby_Messages_Types_CHANGE_OWNER = 2,
  Lobby_Messages_Types_MEMBER_DATA = 3,
  Lobby_Messages_Types_CHAT_MESSAGE = 4,
  Lobby_Messages_Types_Lobby_Messages_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Lobby_Messages_Types_Lobby_Messages_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Lobby_Messages_Types_IsValid(int value);
constexpr Lobby_Messages_Types Lobby_Messages_Types_Types_MIN = Lobby_Messages_Types_JOIN;
constexpr Lobby_Messages_Types Lobby_Messages_Types_Types_MAX = Lobby_Messages_Types_CHAT_MESSAGE;
constexpr int Lobby_Messages_Types_Types_ARRAYSIZE = Lobby_Messages_Types_Types_MAX + 1;

const std::string& Lobby_Messages_Types_Name(Lobby_Messages_Types value);
template<typename T>
inline const std::string& Lobby_Messages_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Lobby_Messages_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Lobby_Messages_Types_Name.");
  return Lobby_Messages_Types_Name(static_cast<Lobby_Messages_Types>(enum_t_value));
}
bool Lobby_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Lobby_Messages_Types* value);
enum Low_Level_Types : int {
  Low_Level_Types_HEARTBEAT = 0,
  Low_Level_Types_CONNECT = 1,
  Low_Level_Types_DISCONNECT = 2,
  Low_Level_Types_Low_Level_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Low_Level_Types_Low_Level_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Low_Level_Types_IsValid(int value);
constexpr Low_Level_Types Low_Level_Types_Types_MIN = Low_Level_Types_HEARTBEAT;
constexpr Low_Level_Types Low_Level_Types_Types_MAX = Low_Level_Types_DISCONNECT;
constexpr int Low_Level_Types_Types_ARRAYSIZE = Low_Level_Types_Types_MAX + 1;

const std::string& Low_Level_Types_Name(Low_Level_Types value);
template<typename T>
inline const std::string& Low_Level_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Low_Level_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Low_Level_Types_Name.");
  return Low_Level_Types_Name(static_cast<Low_Level_Types>(enum_t_value));
}
bool Low_Level_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Low_Level_Types* value);
enum Network_pb_Types : int {
  Network_pb_Types_DATA = 0,
  Network_pb_Types_NEW_CONNECTION = 1,
  Network_pb_Types_Network_pb_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Network_pb_Types_Network_pb_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Network_pb_Types_IsValid(int value);
constexpr Network_pb_Types Network_pb_Types_Types_MIN = Network_pb_Types_DATA;
constexpr Network_pb_Types Network_pb_Types_Types_MAX = Network_pb_Types_NEW_CONNECTION;
constexpr int Network_pb_Types_Types_ARRAYSIZE = Network_pb_Types_Types_MAX + 1;

const std::string& Network_pb_Types_Name(Network_pb_Types value);
template<typename T>
inline const std::string& Network_pb_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Network_pb_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Network_pb_Types_Name.");
  return Network_pb_Types_Name(static_cast<Network_pb_Types>(enum_t_value));
}
bool Network_pb_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Network_pb_Types* value);
enum Network_Old_Types : int {
  Network_Old_Types_CONNECTION_REQUEST_IP = 0,
  Network_Old_Types_CONNECTION_REQUEST_STEAMID = 1,
  Network_Old_Types_CONNECTION_ACCEPTED = 2,
  Network_Old_Types_CONNECTION_END = 3,
  Network_Old_Types_DATA = 4,
  Network_Old_Types_Network_Old_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Network_Old_Types_Network_Old_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Network_Old_Types_IsValid(int value);
constexpr Network_Old_Types Network_Old_Types_Types_MIN = Network_Old_Types_CONNECTION_REQUEST_IP;
constexpr Network_Old_Types Network_Old_Types_Types_MAX = Network_Old_Types_DATA;
constexpr int Network_Old_Types_Types_ARRAYSIZE = Network_Old_Types_Types_MAX + 1;

const std::string& Network_Old_Types_Name(Network_Old_Types value);
template<typename T>
inline const std::string& Network_Old_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Network_Old_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Network_Old_Types_Name.");
  return Network_Old_Types_Name(static_cast<Network_Old_Types>(enum_t_value));
}
bool Network_Old_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Network_Old_Types* value);
enum Networking_Sockets_Types : int {
  Networking_Sockets_Types_CONNECTION_REQUEST = 0,
  Networking_Sockets_Types_CONNECTION_ACCEPTED = 2,
  Networking_Sockets_Types_CONNECTION_END = 3,
  Networking_Sockets_Types_DATA = 4,
  Networking_Sockets_Types_Networking_Sockets_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Networking_Sockets_Types_Networking_Sockets_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Networking_Sockets_Types_IsValid(int value);
constexpr Networking_Sockets_Types Networking_Sockets_Types_Types_MIN = Networking_Sockets_Types_CONNECTION_REQUEST;
constexpr Networking_Sockets_Types Networking_Sockets_Types_Types_MAX = Networking_Sockets_Types_DATA;
constexpr int Networking_Sockets_Types_Types_ARRAYSIZE = Networking_Sockets_Types_Types_MAX + 1;

const std::string& Networking_Sockets_Types_Name(Networking_Sockets_Types value);
template<typename T>
inline const std::string& Networking_Sockets_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Networking_Sockets_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Networking_Sockets_Types_Name.");
  return Networking_Sockets_Types_Name(static_cast<Networking_Sockets_Types>(enum_t_value));
}
bool Networking_Sockets_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Networking_Sockets_Types* value);
enum Networking_Messages_Types : int {
  Networking_Messages_Types_CONNECTION_NEW = 0,
  Networking_Messages_Types_CONNECTION_ACCEPT = 1,
  Networking_Messages_Types_CONNECTION_END = 2,
  Networking_Messages_Types_DATA = 3,
  Networking_Messages_Types_Networking_Messages_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Networking_Messages_Types_Networking_Messages_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Networking_Messages_Types_IsValid(int value);
constexpr Networking_Messages_Types Networking_Messages_Types_Types_MIN = Networking_Messages_Types_CONNECTION_NEW;
constexpr Networking_Messages_Types Networking_Messages_Types_Types_MAX = Networking_Messages_Types_DATA;
constexpr int Networking_Messages_Types_Types_ARRAYSIZE = Networking_Messages_Types_Types_MAX + 1;

const std::string& Networking_Messages_Types_Name(Networking_Messages_Types value);
template<typename T>
inline const std::string& Networking_Messages_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Networking_Messages_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Networking_Messages_Types_Name.");
  return Networking_Messages_Types_Name(static_cast<Networking_Messages_Types>(enum_t_value));
}
bool Networking_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Networking_Messages_Types* value);
enum Auth_Ticket_Types : int {
  Auth_Ticket_Types_CANCEL = 0,
  Auth_Ticket_Types_Auth_Ticket_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Auth_Ticket_Types_Auth_Ticket_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Auth_Ticket_Types_IsValid(int value);
constexpr Auth_Ticket_Types Auth_Ticket_Types_Types_MIN = Auth_Ticket_Types_CANCEL;
constexpr Auth_Ticket_Types Auth_Ticket_Types_Types_MAX = Auth_Ticket_Types_CANCEL;
constexpr int Auth_Ticket_Types_Types_ARRAYSIZE = Auth_Ticket_Types_Types_MAX + 1;

const std::string& Auth_Ticket_Types_Name(Auth_Ticket_Types value);
template<typename T>
inline const std::string& Auth_Ticket_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Auth_Ticket_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Auth_Ticket_Types_Name.");
  return Auth_Ticket_Types_Name(static_cast<Auth_Ticket_Types>(enum_t_value));
}
bool Auth_Ticket_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Auth_Ticket_Types* value);
enum Friend_Messages_Types : int {
  Friend_Messages_Types_LOBBY_INVITE = 0,
  Friend_Messages_Types_GAME_INVITE = 1,
  Friend_Messages_Types_Friend_Messages_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Friend_Messages_Types_Friend_Messages_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Friend_Messages_Types_IsValid(int value);
constexpr Friend_Messages_Types Friend_Messages_Types_Types_MIN = Friend_Messages_Types_LOBBY_INVITE;
constexpr Friend_Messages_Types Friend_Messages_Types_Types_MAX = Friend_Messages_Types_GAME_INVITE;
constexpr int Friend_Messages_Types_Types_ARRAYSIZE = Friend_Messages_Types_Types_MAX + 1;

const std::string& Friend_Messages_Types_Name(Friend_Messages_Types value);
template<typename T>
inline const std::string& Friend_Messages_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Friend_Messages_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Friend_Messages_Types_Name.");
  return Friend_Messages_Types_Name(static_cast<Friend_Messages_Types>(enum_t_value));
}
bool Friend_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Friend_Messages_Types* value);
enum Steam_Messages_Types : int {
  Steam_Messages_Types_FRIEND_CHAT = 0,
  Steam_Messages_Types_Steam_Messages_Types_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Steam_Messages_Types_Steam_Messages_Types_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Steam_Messages_Types_IsValid(int value);
constexpr Steam_Messages_Types Steam_Messages_Types_Types_MIN = Steam_Messages_Types_FRIEND_CHAT;
constexpr Steam_Messages_Types Steam_Messages_Types_Types_MAX = Steam_Messages_Types_FRIEND_CHAT;
constexpr int Steam_Messages_Types_Types_ARRAYSIZE = Steam_Messages_Types_Types_MAX + 1;

const std::string& Steam_Messages_Types_Name(Steam_Messages_Types value);
template<typename T>
inline const std::string& Steam_Messages_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Steam_Messages_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Steam_Messages_Types_Name.");
  return Steam_Messages_Types_Name(static_cast<Steam_Messages_Types>(enum_t_value));
}
bool Steam_Messages_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Steam_Messages_Types* value);
// ===================================================================

class Announce_Other_Peers final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Announce.Other_Peers) */ {
 public:
  inline Announce_Other_Peers() : Announce_Other_Peers(nullptr) {}
  ~Announce_Other_Peers() override;
  explicit PROTOBUF_CONSTEXPR Announce_Other_Peers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Announce_Other_Peers(const Announce_Other_Peers& from);
  Announce_Other_Peers(Announce_Other_Peers&& from) noexcept
    : Announce_Other_Peers() {
    *this = ::std::move(from);
  }

  inline Announce_Other_Peers& operator=(const Announce_Other_Peers& from) {
    CopyFrom(from);
    return *this;
  }
  inline Announce_Other_Peers& operator=(Announce_Other_Peers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Announce_Other_Peers& default_instance() {
    return *internal_default_instance();
  }
  static inline const Announce_Other_Peers* internal_default_instance() {
    return reinterpret_cast<const Announce_Other_Peers*>(
               &_Announce_Other_Peers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Announce_Other_Peers& a, Announce_Other_Peers& b) {
    a.Swap(&b);
  }
  inline void Swap(Announce_Other_Peers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Announce_Other_Peers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Announce_Other_Peers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Announce_Other_Peers>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Announce_Other_Peers& from);
  void MergeFrom(const Announce_Other_Peers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Announce_Other_Peers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Announce.Other_Peers";
  }
  protected:
  explicit Announce_Other_Peers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIpFieldNumber = 2,
    kUdpPortFieldNumber = 3,
    kAppidFieldNumber = 4,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint32 ip = 2;
  void clear_ip();
  uint32_t ip() const;
  void set_ip(uint32_t value);
  private:
  uint32_t _internal_ip() const;
  void _internal_set_ip(uint32_t value);
  public:

  // uint32 udp_port = 3;
  void clear_udp_port();
  uint32_t udp_port() const;
  void set_udp_port(uint32_t value);
  private:
  uint32_t _internal_udp_port() const;
  void _internal_set_udp_port(uint32_t value);
  public:

  // uint32 appid = 4;
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Announce.Other_Peers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    uint32_t ip_;
    uint32_t udp_port_;
    uint32_t appid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Announce final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Announce) */ {
 public:
  inline Announce() : Announce(nullptr) {}
  ~Announce() override;
  explicit PROTOBUF_CONSTEXPR Announce(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Announce(const Announce& from);
  Announce(Announce&& from) noexcept
    : Announce() {
    *this = ::std::move(from);
  }

  inline Announce& operator=(const Announce& from) {
    CopyFrom(from);
    return *this;
  }
  inline Announce& operator=(Announce&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Announce& default_instance() {
    return *internal_default_instance();
  }
  static inline const Announce* internal_default_instance() {
    return reinterpret_cast<const Announce*>(
               &_Announce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Announce& a, Announce& b) {
    a.Swap(&b);
  }
  inline void Swap(Announce* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Announce* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Announce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Announce>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Announce& from);
  void MergeFrom(const Announce& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Announce* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Announce";
  }
  protected:
  explicit Announce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Announce_Other_Peers Other_Peers;

  typedef Announce_Types Types;
  static constexpr Types PING =
    Announce_Types_PING;
  static constexpr Types PONG =
    Announce_Types_PONG;
  static inline bool Types_IsValid(int value) {
    return Announce_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Announce_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Announce_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Announce_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Announce_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Announce_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 2,
    kPeersFieldNumber = 4,
    kTypeFieldNumber = 1,
    kTcpPortFieldNumber = 3,
    kAppidFieldNumber = 5,
  };
  // repeated uint64 ids = 2;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  uint64_t _internal_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_ids() const;
  void _internal_add_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_ids();
  public:
  uint64_t ids(int index) const;
  void set_ids(int index, uint64_t value);
  void add_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_ids();

  // repeated .Announce.Other_Peers peers = 4;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::Announce_Other_Peers* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers >*
      mutable_peers();
  private:
  const ::Announce_Other_Peers& _internal_peers(int index) const;
  ::Announce_Other_Peers* _internal_add_peers();
  public:
  const ::Announce_Other_Peers& peers(int index) const;
  ::Announce_Other_Peers* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers >&
      peers() const;

  // .Announce.Types type = 1;
  void clear_type();
  ::Announce_Types type() const;
  void set_type(::Announce_Types value);
  private:
  ::Announce_Types _internal_type() const;
  void _internal_set_type(::Announce_Types value);
  public:

  // uint32 tcp_port = 3;
  void clear_tcp_port();
  uint32_t tcp_port() const;
  void set_tcp_port(uint32_t value);
  private:
  uint32_t _internal_tcp_port() const;
  void _internal_set_tcp_port(uint32_t value);
  public:

  // uint32 appid = 5;
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Announce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > ids_;
    mutable std::atomic<int> _ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers > peers_;
    int type_;
    uint32_t tcp_port_;
    uint32_t appid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Lobby_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Lobby_ValuesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Lobby_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Lobby_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Lobby_ValuesEntry_DoNotUse& other);
  static const Lobby_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Lobby_ValuesEntry_DoNotUse*>(&_Lobby_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Lobby.ValuesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_net_2eproto;
};

// -------------------------------------------------------------------

class Lobby_Member_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_Member_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_Member_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Lobby_Member_ValuesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Lobby_Member_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Lobby_Member_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Lobby_Member_ValuesEntry_DoNotUse& other);
  static const Lobby_Member_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Lobby_Member_ValuesEntry_DoNotUse*>(&_Lobby_Member_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Lobby.Member.ValuesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_net_2eproto;
};

// -------------------------------------------------------------------

class Lobby_Member final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Lobby.Member) */ {
 public:
  inline Lobby_Member() : Lobby_Member(nullptr) {}
  ~Lobby_Member() override;
  explicit PROTOBUF_CONSTEXPR Lobby_Member(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lobby_Member(const Lobby_Member& from);
  Lobby_Member(Lobby_Member&& from) noexcept
    : Lobby_Member() {
    *this = ::std::move(from);
  }

  inline Lobby_Member& operator=(const Lobby_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lobby_Member& operator=(Lobby_Member&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Lobby_Member& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lobby_Member* internal_default_instance() {
    return reinterpret_cast<const Lobby_Member*>(
               &_Lobby_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Lobby_Member& a, Lobby_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(Lobby_Member* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lobby_Member* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lobby_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lobby_Member>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Lobby_Member& from);
  void MergeFrom(const Lobby_Member& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lobby_Member* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Lobby.Member";
  }
  protected:
  explicit Lobby_Member(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // map<string, bytes> values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_values();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Lobby.Member)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
        Lobby_Member_ValuesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> values_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Lobby_Gameserver final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Lobby.Gameserver) */ {
 public:
  inline Lobby_Gameserver() : Lobby_Gameserver(nullptr) {}
  ~Lobby_Gameserver() override;
  explicit PROTOBUF_CONSTEXPR Lobby_Gameserver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lobby_Gameserver(const Lobby_Gameserver& from);
  Lobby_Gameserver(Lobby_Gameserver&& from) noexcept
    : Lobby_Gameserver() {
    *this = ::std::move(from);
  }

  inline Lobby_Gameserver& operator=(const Lobby_Gameserver& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lobby_Gameserver& operator=(Lobby_Gameserver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Lobby_Gameserver& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lobby_Gameserver* internal_default_instance() {
    return reinterpret_cast<const Lobby_Gameserver*>(
               &_Lobby_Gameserver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Lobby_Gameserver& a, Lobby_Gameserver& b) {
    a.Swap(&b);
  }
  inline void Swap(Lobby_Gameserver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lobby_Gameserver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lobby_Gameserver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lobby_Gameserver>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Lobby_Gameserver& from);
  void MergeFrom(const Lobby_Gameserver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lobby_Gameserver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Lobby.Gameserver";
  }
  protected:
  explicit Lobby_Gameserver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIpFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint32 ip = 2;
  void clear_ip();
  uint32_t ip() const;
  void set_ip(uint32_t value);
  private:
  uint32_t _internal_ip() const;
  void _internal_set_ip(uint32_t value);
  public:

  // uint32 port = 3;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Lobby.Gameserver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    uint32_t ip_;
    uint32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Lobby final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Lobby) */ {
 public:
  inline Lobby() : Lobby(nullptr) {}
  ~Lobby() override;
  explicit PROTOBUF_CONSTEXPR Lobby(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lobby(const Lobby& from);
  Lobby(Lobby&& from) noexcept
    : Lobby() {
    *this = ::std::move(from);
  }

  inline Lobby& operator=(const Lobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lobby& operator=(Lobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Lobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lobby* internal_default_instance() {
    return reinterpret_cast<const Lobby*>(
               &_Lobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Lobby& a, Lobby& b) {
    a.Swap(&b);
  }
  inline void Swap(Lobby* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lobby* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lobby* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lobby>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Lobby& from);
  void MergeFrom(const Lobby& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lobby* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Lobby";
  }
  protected:
  explicit Lobby(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Lobby_Member Member;
  typedef Lobby_Gameserver Gameserver;

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kMembersFieldNumber = 4,
    kGameserverFieldNumber = 5,
    kRoomIdFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kMemberLimitFieldNumber = 6,
    kTypeFieldNumber = 7,
    kAppidFieldNumber = 9,
    kJoinableFieldNumber = 8,
    kDeletedFieldNumber = 32,
    kTimeDeletedFieldNumber = 33,
  };
  // map<string, bytes> values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_values();

  // repeated .Lobby.Member members = 4;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::Lobby_Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member >*
      mutable_members();
  private:
  const ::Lobby_Member& _internal_members(int index) const;
  ::Lobby_Member* _internal_add_members();
  public:
  const ::Lobby_Member& members(int index) const;
  ::Lobby_Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member >&
      members() const;

  // .Lobby.Gameserver gameserver = 5;
  bool has_gameserver() const;
  private:
  bool _internal_has_gameserver() const;
  public:
  void clear_gameserver();
  const ::Lobby_Gameserver& gameserver() const;
  PROTOBUF_NODISCARD ::Lobby_Gameserver* release_gameserver();
  ::Lobby_Gameserver* mutable_gameserver();
  void set_allocated_gameserver(::Lobby_Gameserver* gameserver);
  private:
  const ::Lobby_Gameserver& _internal_gameserver() const;
  ::Lobby_Gameserver* _internal_mutable_gameserver();
  public:
  void unsafe_arena_set_allocated_gameserver(
      ::Lobby_Gameserver* gameserver);
  ::Lobby_Gameserver* unsafe_arena_release_gameserver();

  // uint64 room_id = 1;
  void clear_room_id();
  uint64_t room_id() const;
  void set_room_id(uint64_t value);
  private:
  uint64_t _internal_room_id() const;
  void _internal_set_room_id(uint64_t value);
  public:

  // uint64 owner = 2;
  void clear_owner();
  uint64_t owner() const;
  void set_owner(uint64_t value);
  private:
  uint64_t _internal_owner() const;
  void _internal_set_owner(uint64_t value);
  public:

  // uint32 member_limit = 6;
  void clear_member_limit();
  uint32_t member_limit() const;
  void set_member_limit(uint32_t value);
  private:
  uint32_t _internal_member_limit() const;
  void _internal_set_member_limit(uint32_t value);
  public:

  // uint32 type = 7;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 appid = 9;
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // bool joinable = 8;
  void clear_joinable();
  bool joinable() const;
  void set_joinable(bool value);
  private:
  bool _internal_joinable() const;
  void _internal_set_joinable(bool value);
  public:

  // bool deleted = 32;
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // uint64 time_deleted = 33;
  void clear_time_deleted();
  uint64_t time_deleted() const;
  void set_time_deleted(uint64_t value);
  private:
  uint64_t _internal_time_deleted() const;
  void _internal_set_time_deleted(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Lobby)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
        Lobby_ValuesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member > members_;
    ::Lobby_Gameserver* gameserver_;
    uint64_t room_id_;
    uint64_t owner_;
    uint32_t member_limit_;
    uint32_t type_;
    uint32_t appid_;
    bool joinable_;
    bool deleted_;
    uint64_t time_deleted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Lobby_Messages_MapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_Messages_MapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Lobby_Messages_MapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Lobby_Messages_MapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Lobby_Messages_MapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Lobby_Messages_MapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Lobby_Messages_MapEntry_DoNotUse& other);
  static const Lobby_Messages_MapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Lobby_Messages_MapEntry_DoNotUse*>(&_Lobby_Messages_MapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Lobby_Messages.MapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_net_2eproto;
};

// -------------------------------------------------------------------

class Lobby_Messages final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Lobby_Messages) */ {
 public:
  inline Lobby_Messages() : Lobby_Messages(nullptr) {}
  ~Lobby_Messages() override;
  explicit PROTOBUF_CONSTEXPR Lobby_Messages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lobby_Messages(const Lobby_Messages& from);
  Lobby_Messages(Lobby_Messages&& from) noexcept
    : Lobby_Messages() {
    *this = ::std::move(from);
  }

  inline Lobby_Messages& operator=(const Lobby_Messages& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lobby_Messages& operator=(Lobby_Messages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Lobby_Messages& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lobby_Messages* internal_default_instance() {
    return reinterpret_cast<const Lobby_Messages*>(
               &_Lobby_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Lobby_Messages& a, Lobby_Messages& b) {
    a.Swap(&b);
  }
  inline void Swap(Lobby_Messages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lobby_Messages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lobby_Messages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lobby_Messages>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Lobby_Messages& from);
  void MergeFrom(const Lobby_Messages& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lobby_Messages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Lobby_Messages";
  }
  protected:
  explicit Lobby_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  typedef Lobby_Messages_Types Types;
  static constexpr Types JOIN =
    Lobby_Messages_Types_JOIN;
  static constexpr Types LEAVE =
    Lobby_Messages_Types_LEAVE;
  static constexpr Types CHANGE_OWNER =
    Lobby_Messages_Types_CHANGE_OWNER;
  static constexpr Types MEMBER_DATA =
    Lobby_Messages_Types_MEMBER_DATA;
  static constexpr Types CHAT_MESSAGE =
    Lobby_Messages_Types_CHAT_MESSAGE;
  static inline bool Types_IsValid(int value) {
    return Lobby_Messages_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Lobby_Messages_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Lobby_Messages_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Lobby_Messages_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Lobby_Messages_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Lobby_Messages_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMapFieldNumber = 5,
    kBdataFieldNumber = 4,
    kIdFieldNumber = 1,
    kIdataFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // map<string, bytes> map = 5;
  int map_size() const;
  private:
  int _internal_map_size() const;
  public:
  void clear_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_map();

  // bytes bdata = 4;
  void clear_bdata();
  const std::string& bdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bdata();
  PROTOBUF_NODISCARD std::string* release_bdata();
  void set_allocated_bdata(std::string* bdata);
  private:
  const std::string& _internal_bdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bdata(const std::string& value);
  std::string* _internal_mutable_bdata();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 idata = 3;
  void clear_idata();
  uint64_t idata() const;
  void set_idata(uint64_t value);
  private:
  uint64_t _internal_idata() const;
  void _internal_set_idata(uint64_t value);
  public:

  // .Lobby_Messages.Types type = 2;
  void clear_type();
  ::Lobby_Messages_Types type() const;
  void set_type(::Lobby_Messages_Types value);
  private:
  ::Lobby_Messages_Types _internal_type() const;
  void _internal_set_type(::Lobby_Messages_Types value);
  public:

  // @@protoc_insertion_point(class_scope:Lobby_Messages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
        Lobby_Messages_MapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> map_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bdata_;
    uint64_t id_;
    uint64_t idata_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Low_Level final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Low_Level) */ {
 public:
  inline Low_Level() : Low_Level(nullptr) {}
  ~Low_Level() override;
  explicit PROTOBUF_CONSTEXPR Low_Level(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Low_Level(const Low_Level& from);
  Low_Level(Low_Level&& from) noexcept
    : Low_Level() {
    *this = ::std::move(from);
  }

  inline Low_Level& operator=(const Low_Level& from) {
    CopyFrom(from);
    return *this;
  }
  inline Low_Level& operator=(Low_Level&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Low_Level& default_instance() {
    return *internal_default_instance();
  }
  static inline const Low_Level* internal_default_instance() {
    return reinterpret_cast<const Low_Level*>(
               &_Low_Level_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Low_Level& a, Low_Level& b) {
    a.Swap(&b);
  }
  inline void Swap(Low_Level* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Low_Level* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Low_Level* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Low_Level>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Low_Level& from);
  void MergeFrom(const Low_Level& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Low_Level* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Low_Level";
  }
  protected:
  explicit Low_Level(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Low_Level_Types Types;
  static constexpr Types HEARTBEAT =
    Low_Level_Types_HEARTBEAT;
  static constexpr Types CONNECT =
    Low_Level_Types_CONNECT;
  static constexpr Types DISCONNECT =
    Low_Level_Types_DISCONNECT;
  static inline bool Types_IsValid(int value) {
    return Low_Level_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Low_Level_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Low_Level_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Low_Level_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Low_Level_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Low_Level_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .Low_Level.Types type = 1;
  void clear_type();
  ::Low_Level_Types type() const;
  void set_type(::Low_Level_Types value);
  private:
  ::Low_Level_Types _internal_type() const;
  void _internal_set_type(::Low_Level_Types value);
  public:

  // @@protoc_insertion_point(class_scope:Low_Level)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Network_pb final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Network_pb) */ {
 public:
  inline Network_pb() : Network_pb(nullptr) {}
  ~Network_pb() override;
  explicit PROTOBUF_CONSTEXPR Network_pb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Network_pb(const Network_pb& from);
  Network_pb(Network_pb&& from) noexcept
    : Network_pb() {
    *this = ::std::move(from);
  }

  inline Network_pb& operator=(const Network_pb& from) {
    CopyFrom(from);
    return *this;
  }
  inline Network_pb& operator=(Network_pb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Network_pb& default_instance() {
    return *internal_default_instance();
  }
  static inline const Network_pb* internal_default_instance() {
    return reinterpret_cast<const Network_pb*>(
               &_Network_pb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Network_pb& a, Network_pb& b) {
    a.Swap(&b);
  }
  inline void Swap(Network_pb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Network_pb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Network_pb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Network_pb>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Network_pb& from);
  void MergeFrom(const Network_pb& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Network_pb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Network_pb";
  }
  protected:
  explicit Network_pb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Network_pb_Types Types;
  static constexpr Types DATA =
    Network_pb_Types_DATA;
  static constexpr Types NEW_CONNECTION =
    Network_pb_Types_NEW_CONNECTION;
  static inline bool Types_IsValid(int value) {
    return Network_pb_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Network_pb_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Network_pb_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Network_pb_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Network_pb_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Network_pb_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kChannelFieldNumber = 1,
    kTypeFieldNumber = 3,
    kTimeProcessedFieldNumber = 129,
    kProcessedFieldNumber = 128,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 channel = 1;
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // .Network_pb.Types type = 3;
  void clear_type();
  ::Network_pb_Types type() const;
  void set_type(::Network_pb_Types value);
  private:
  ::Network_pb_Types _internal_type() const;
  void _internal_set_type(::Network_pb_Types value);
  public:

  // uint64 time_processed = 129;
  void clear_time_processed();
  uint64_t time_processed() const;
  void set_time_processed(uint64_t value);
  private:
  uint64_t _internal_time_processed() const;
  void _internal_set_time_processed(uint64_t value);
  public:

  // bool processed = 128;
  void clear_processed();
  bool processed() const;
  void set_processed(bool value);
  private:
  bool _internal_processed() const;
  void _internal_set_processed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Network_pb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint32_t channel_;
    int type_;
    uint64_t time_processed_;
    bool processed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Network_Old final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Network_Old) */ {
 public:
  inline Network_Old() : Network_Old(nullptr) {}
  ~Network_Old() override;
  explicit PROTOBUF_CONSTEXPR Network_Old(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Network_Old(const Network_Old& from);
  Network_Old(Network_Old&& from) noexcept
    : Network_Old() {
    *this = ::std::move(from);
  }

  inline Network_Old& operator=(const Network_Old& from) {
    CopyFrom(from);
    return *this;
  }
  inline Network_Old& operator=(Network_Old&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Network_Old& default_instance() {
    return *internal_default_instance();
  }
  static inline const Network_Old* internal_default_instance() {
    return reinterpret_cast<const Network_Old*>(
               &_Network_Old_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Network_Old& a, Network_Old& b) {
    a.Swap(&b);
  }
  inline void Swap(Network_Old* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Network_Old* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Network_Old* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Network_Old>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Network_Old& from);
  void MergeFrom(const Network_Old& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Network_Old* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Network_Old";
  }
  protected:
  explicit Network_Old(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Network_Old_Types Types;
  static constexpr Types CONNECTION_REQUEST_IP =
    Network_Old_Types_CONNECTION_REQUEST_IP;
  static constexpr Types CONNECTION_REQUEST_STEAMID =
    Network_Old_Types_CONNECTION_REQUEST_STEAMID;
  static constexpr Types CONNECTION_ACCEPTED =
    Network_Old_Types_CONNECTION_ACCEPTED;
  static constexpr Types CONNECTION_END =
    Network_Old_Types_CONNECTION_END;
  static constexpr Types DATA =
    Network_Old_Types_DATA;
  static inline bool Types_IsValid(int value) {
    return Network_Old_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Network_Old_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Network_Old_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Network_Old_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Network_Old_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Network_Old_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kConnectionIdFieldNumber = 2,
    kTypeFieldNumber = 1,
    kPortFieldNumber = 4,
    kConnectionIdFromFieldNumber = 3,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 connection_id = 2;
  void clear_connection_id();
  uint64_t connection_id() const;
  void set_connection_id(uint64_t value);
  private:
  uint64_t _internal_connection_id() const;
  void _internal_set_connection_id(uint64_t value);
  public:

  // .Network_Old.Types type = 1;
  void clear_type();
  ::Network_Old_Types type() const;
  void set_type(::Network_Old_Types value);
  private:
  ::Network_Old_Types _internal_type() const;
  void _internal_set_type(::Network_Old_Types value);
  public:

  // uint32 port = 4;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // uint64 connection_id_from = 3;
  void clear_connection_id_from();
  uint64_t connection_id_from() const;
  void set_connection_id_from(uint64_t value);
  private:
  uint64_t _internal_connection_id_from() const;
  void _internal_set_connection_id_from(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Network_Old)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t connection_id_;
    int type_;
    uint32_t port_;
    uint64_t connection_id_from_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Networking_Sockets final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Networking_Sockets) */ {
 public:
  inline Networking_Sockets() : Networking_Sockets(nullptr) {}
  ~Networking_Sockets() override;
  explicit PROTOBUF_CONSTEXPR Networking_Sockets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Networking_Sockets(const Networking_Sockets& from);
  Networking_Sockets(Networking_Sockets&& from) noexcept
    : Networking_Sockets() {
    *this = ::std::move(from);
  }

  inline Networking_Sockets& operator=(const Networking_Sockets& from) {
    CopyFrom(from);
    return *this;
  }
  inline Networking_Sockets& operator=(Networking_Sockets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Networking_Sockets& default_instance() {
    return *internal_default_instance();
  }
  static inline const Networking_Sockets* internal_default_instance() {
    return reinterpret_cast<const Networking_Sockets*>(
               &_Networking_Sockets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Networking_Sockets& a, Networking_Sockets& b) {
    a.Swap(&b);
  }
  inline void Swap(Networking_Sockets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Networking_Sockets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Networking_Sockets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Networking_Sockets>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Networking_Sockets& from);
  void MergeFrom(const Networking_Sockets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Networking_Sockets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Networking_Sockets";
  }
  protected:
  explicit Networking_Sockets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Networking_Sockets_Types Types;
  static constexpr Types CONNECTION_REQUEST =
    Networking_Sockets_Types_CONNECTION_REQUEST;
  static constexpr Types CONNECTION_ACCEPTED =
    Networking_Sockets_Types_CONNECTION_ACCEPTED;
  static constexpr Types CONNECTION_END =
    Networking_Sockets_Types_CONNECTION_END;
  static constexpr Types DATA =
    Networking_Sockets_Types_DATA;
  static inline bool Types_IsValid(int value) {
    return Networking_Sockets_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Networking_Sockets_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Networking_Sockets_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Networking_Sockets_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Networking_Sockets_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Networking_Sockets_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kTypeFieldNumber = 1,
    kVirtualPortFieldNumber = 2,
    kConnectionIdFieldNumber = 3,
    kConnectionIdFromFieldNumber = 4,
    kRealPortFieldNumber = 6,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .Networking_Sockets.Types type = 1;
  void clear_type();
  ::Networking_Sockets_Types type() const;
  void set_type(::Networking_Sockets_Types value);
  private:
  ::Networking_Sockets_Types _internal_type() const;
  void _internal_set_type(::Networking_Sockets_Types value);
  public:

  // int32 virtual_port = 2;
  void clear_virtual_port();
  int32_t virtual_port() const;
  void set_virtual_port(int32_t value);
  private:
  int32_t _internal_virtual_port() const;
  void _internal_set_virtual_port(int32_t value);
  public:

  // uint64 connection_id = 3;
  void clear_connection_id();
  uint64_t connection_id() const;
  void set_connection_id(uint64_t value);
  private:
  uint64_t _internal_connection_id() const;
  void _internal_set_connection_id(uint64_t value);
  public:

  // uint64 connection_id_from = 4;
  void clear_connection_id_from();
  uint64_t connection_id_from() const;
  void set_connection_id_from(uint64_t value);
  private:
  uint64_t _internal_connection_id_from() const;
  void _internal_set_connection_id_from(uint64_t value);
  public:

  // int32 real_port = 6;
  void clear_real_port();
  int32_t real_port() const;
  void set_real_port(int32_t value);
  private:
  int32_t _internal_real_port() const;
  void _internal_set_real_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Networking_Sockets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int type_;
    int32_t virtual_port_;
    uint64_t connection_id_;
    uint64_t connection_id_from_;
    int32_t real_port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Networking_Messages final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Networking_Messages) */ {
 public:
  inline Networking_Messages() : Networking_Messages(nullptr) {}
  ~Networking_Messages() override;
  explicit PROTOBUF_CONSTEXPR Networking_Messages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Networking_Messages(const Networking_Messages& from);
  Networking_Messages(Networking_Messages&& from) noexcept
    : Networking_Messages() {
    *this = ::std::move(from);
  }

  inline Networking_Messages& operator=(const Networking_Messages& from) {
    CopyFrom(from);
    return *this;
  }
  inline Networking_Messages& operator=(Networking_Messages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Networking_Messages& default_instance() {
    return *internal_default_instance();
  }
  static inline const Networking_Messages* internal_default_instance() {
    return reinterpret_cast<const Networking_Messages*>(
               &_Networking_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Networking_Messages& a, Networking_Messages& b) {
    a.Swap(&b);
  }
  inline void Swap(Networking_Messages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Networking_Messages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Networking_Messages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Networking_Messages>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Networking_Messages& from);
  void MergeFrom(const Networking_Messages& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Networking_Messages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Networking_Messages";
  }
  protected:
  explicit Networking_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Networking_Messages_Types Types;
  static constexpr Types CONNECTION_NEW =
    Networking_Messages_Types_CONNECTION_NEW;
  static constexpr Types CONNECTION_ACCEPT =
    Networking_Messages_Types_CONNECTION_ACCEPT;
  static constexpr Types CONNECTION_END =
    Networking_Messages_Types_CONNECTION_END;
  static constexpr Types DATA =
    Networking_Messages_Types_DATA;
  static inline bool Types_IsValid(int value) {
    return Networking_Messages_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Networking_Messages_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Networking_Messages_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Networking_Messages_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Networking_Messages_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Networking_Messages_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kTypeFieldNumber = 1,
    kChannelFieldNumber = 2,
    kIdFromFieldNumber = 3,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .Networking_Messages.Types type = 1;
  void clear_type();
  ::Networking_Messages_Types type() const;
  void set_type(::Networking_Messages_Types value);
  private:
  ::Networking_Messages_Types _internal_type() const;
  void _internal_set_type(::Networking_Messages_Types value);
  public:

  // uint32 channel = 2;
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // uint32 id_from = 3;
  void clear_id_from();
  uint32_t id_from() const;
  void set_id_from(uint32_t value);
  private:
  uint32_t _internal_id_from() const;
  void _internal_set_id_from(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Networking_Messages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int type_;
    uint32_t channel_;
    uint32_t id_from_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Gameserver_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Gameserver_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Gameserver_ValuesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Gameserver_ValuesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Gameserver_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Gameserver_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Gameserver_ValuesEntry_DoNotUse& other);
  static const Gameserver_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Gameserver_ValuesEntry_DoNotUse*>(&_Gameserver_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Gameserver.ValuesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_net_2eproto;
};

// -------------------------------------------------------------------

class Gameserver final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Gameserver) */ {
 public:
  inline Gameserver() : Gameserver(nullptr) {}
  ~Gameserver() override;
  explicit PROTOBUF_CONSTEXPR Gameserver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gameserver(const Gameserver& from);
  Gameserver(Gameserver&& from) noexcept
    : Gameserver() {
    *this = ::std::move(from);
  }

  inline Gameserver& operator=(const Gameserver& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gameserver& operator=(Gameserver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Gameserver& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gameserver* internal_default_instance() {
    return reinterpret_cast<const Gameserver*>(
               &_Gameserver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Gameserver& a, Gameserver& b) {
    a.Swap(&b);
  }
  inline void Swap(Gameserver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gameserver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gameserver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gameserver>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Gameserver& from);
  void MergeFrom(const Gameserver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Gameserver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Gameserver";
  }
  protected:
  explicit Gameserver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 12,
    kGameDescriptionFieldNumber = 2,
    kModDirFieldNumber = 3,
    kServerNameFieldNumber = 7,
    kMapNameFieldNumber = 8,
    kSpectatorServerNameFieldNumber = 11,
    kTagsFieldNumber = 13,
    kGamedataFieldNumber = 14,
    kRegionFieldNumber = 15,
    kProductFieldNumber = 16,
    kIdFieldNumber = 1,
    kMaxPlayerCountFieldNumber = 5,
    kBotPlayerCountFieldNumber = 6,
    kSpectatorPortFieldNumber = 10,
    kNumPlayersFieldNumber = 18,
    kVersionFieldNumber = 19,
    kDedicatedServerFieldNumber = 4,
    kPasswordProtectedFieldNumber = 9,
    kSecureFieldNumber = 17,
    kOfflineFieldNumber = 48,
    kIpFieldNumber = 32,
    kPortFieldNumber = 33,
    kQueryPortFieldNumber = 34,
    kAppidFieldNumber = 35,
  };
  // map<string, bytes> values = 12;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_values();

  // bytes game_description = 2;
  void clear_game_description();
  const std::string& game_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_description();
  PROTOBUF_NODISCARD std::string* release_game_description();
  void set_allocated_game_description(std::string* game_description);
  private:
  const std::string& _internal_game_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_description(const std::string& value);
  std::string* _internal_mutable_game_description();
  public:

  // bytes mod_dir = 3;
  void clear_mod_dir();
  const std::string& mod_dir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mod_dir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mod_dir();
  PROTOBUF_NODISCARD std::string* release_mod_dir();
  void set_allocated_mod_dir(std::string* mod_dir);
  private:
  const std::string& _internal_mod_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mod_dir(const std::string& value);
  std::string* _internal_mutable_mod_dir();
  public:

  // bytes server_name = 7;
  void clear_server_name();
  const std::string& server_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_name();
  PROTOBUF_NODISCARD std::string* release_server_name();
  void set_allocated_server_name(std::string* server_name);
  private:
  const std::string& _internal_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_name(const std::string& value);
  std::string* _internal_mutable_server_name();
  public:

  // bytes map_name = 8;
  void clear_map_name();
  const std::string& map_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_name();
  PROTOBUF_NODISCARD std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // bytes spectator_server_name = 11;
  void clear_spectator_server_name();
  const std::string& spectator_server_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spectator_server_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spectator_server_name();
  PROTOBUF_NODISCARD std::string* release_spectator_server_name();
  void set_allocated_spectator_server_name(std::string* spectator_server_name);
  private:
  const std::string& _internal_spectator_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spectator_server_name(const std::string& value);
  std::string* _internal_mutable_spectator_server_name();
  public:

  // bytes tags = 13;
  void clear_tags();
  const std::string& tags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tags();
  PROTOBUF_NODISCARD std::string* release_tags();
  void set_allocated_tags(std::string* tags);
  private:
  const std::string& _internal_tags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tags(const std::string& value);
  std::string* _internal_mutable_tags();
  public:

  // bytes gamedata = 14;
  void clear_gamedata();
  const std::string& gamedata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gamedata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gamedata();
  PROTOBUF_NODISCARD std::string* release_gamedata();
  void set_allocated_gamedata(std::string* gamedata);
  private:
  const std::string& _internal_gamedata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gamedata(const std::string& value);
  std::string* _internal_mutable_gamedata();
  public:

  // bytes region = 15;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // bytes product = 16;
  void clear_product();
  const std::string& product() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product();
  PROTOBUF_NODISCARD std::string* release_product();
  void set_allocated_product(std::string* product);
  private:
  const std::string& _internal_product() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(const std::string& value);
  std::string* _internal_mutable_product();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint32 max_player_count = 5;
  void clear_max_player_count();
  uint32_t max_player_count() const;
  void set_max_player_count(uint32_t value);
  private:
  uint32_t _internal_max_player_count() const;
  void _internal_set_max_player_count(uint32_t value);
  public:

  // uint32 bot_player_count = 6;
  void clear_bot_player_count();
  uint32_t bot_player_count() const;
  void set_bot_player_count(uint32_t value);
  private:
  uint32_t _internal_bot_player_count() const;
  void _internal_set_bot_player_count(uint32_t value);
  public:

  // uint32 spectator_port = 10;
  void clear_spectator_port();
  uint32_t spectator_port() const;
  void set_spectator_port(uint32_t value);
  private:
  uint32_t _internal_spectator_port() const;
  void _internal_set_spectator_port(uint32_t value);
  public:

  // uint32 num_players = 18;
  void clear_num_players();
  uint32_t num_players() const;
  void set_num_players(uint32_t value);
  private:
  uint32_t _internal_num_players() const;
  void _internal_set_num_players(uint32_t value);
  public:

  // uint32 version = 19;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // bool dedicated_server = 4;
  void clear_dedicated_server();
  bool dedicated_server() const;
  void set_dedicated_server(bool value);
  private:
  bool _internal_dedicated_server() const;
  void _internal_set_dedicated_server(bool value);
  public:

  // bool password_protected = 9;
  void clear_password_protected();
  bool password_protected() const;
  void set_password_protected(bool value);
  private:
  bool _internal_password_protected() const;
  void _internal_set_password_protected(bool value);
  public:

  // bool secure = 17;
  void clear_secure();
  bool secure() const;
  void set_secure(bool value);
  private:
  bool _internal_secure() const;
  void _internal_set_secure(bool value);
  public:

  // bool offline = 48;
  void clear_offline();
  bool offline() const;
  void set_offline(bool value);
  private:
  bool _internal_offline() const;
  void _internal_set_offline(bool value);
  public:

  // uint32 ip = 32;
  void clear_ip();
  uint32_t ip() const;
  void set_ip(uint32_t value);
  private:
  uint32_t _internal_ip() const;
  void _internal_set_ip(uint32_t value);
  public:

  // uint32 port = 33;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // uint32 query_port = 34;
  void clear_query_port();
  uint32_t query_port() const;
  void set_query_port(uint32_t value);
  private:
  uint32_t _internal_query_port() const;
  void _internal_set_query_port(uint32_t value);
  public:

  // uint32 appid = 35;
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Gameserver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
        Gameserver_ValuesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mod_dir_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spectator_server_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamedata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
    uint64_t id_;
    uint32_t max_player_count_;
    uint32_t bot_player_count_;
    uint32_t spectator_port_;
    uint32_t num_players_;
    uint32_t version_;
    bool dedicated_server_;
    bool password_protected_;
    bool secure_;
    bool offline_;
    uint32_t ip_;
    uint32_t port_;
    uint32_t query_port_;
    uint32_t appid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Friend_RichPresenceEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Friend_RichPresenceEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Friend_RichPresenceEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Friend_RichPresenceEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Friend_RichPresenceEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Friend_RichPresenceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Friend_RichPresenceEntry_DoNotUse& other);
  static const Friend_RichPresenceEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Friend_RichPresenceEntry_DoNotUse*>(&_Friend_RichPresenceEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Friend.RichPresenceEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_net_2eproto;
};

// -------------------------------------------------------------------

class Friend final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Friend) */ {
 public:
  inline Friend() : Friend(nullptr) {}
  ~Friend() override;
  explicit PROTOBUF_CONSTEXPR Friend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Friend(const Friend& from);
  Friend(Friend&& from) noexcept
    : Friend() {
    *this = ::std::move(from);
  }

  inline Friend& operator=(const Friend& from) {
    CopyFrom(from);
    return *this;
  }
  inline Friend& operator=(Friend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Friend& default_instance() {
    return *internal_default_instance();
  }
  static inline const Friend* internal_default_instance() {
    return reinterpret_cast<const Friend*>(
               &_Friend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Friend& a, Friend& b) {
    a.Swap(&b);
  }
  inline void Swap(Friend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Friend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Friend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Friend>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Friend& from);
  void MergeFrom(const Friend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Friend* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Friend";
  }
  protected:
  explicit Friend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRichPresenceFieldNumber = 3,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kLobbyIdFieldNumber = 5,
    kAppidFieldNumber = 4,
  };
  // map<string, bytes> rich_presence = 3;
  int rich_presence_size() const;
  private:
  int _internal_rich_presence_size() const;
  public:
  void clear_rich_presence();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_rich_presence() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_rich_presence();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      rich_presence() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_rich_presence();

  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 lobby_id = 5;
  void clear_lobby_id();
  uint64_t lobby_id() const;
  void set_lobby_id(uint64_t value);
  private:
  uint64_t _internal_lobby_id() const;
  void _internal_set_lobby_id(uint64_t value);
  public:

  // uint32 appid = 4;
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Friend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
        Friend_RichPresenceEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> rich_presence_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t id_;
    uint64_t lobby_id_;
    uint32_t appid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Auth_Ticket final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Auth_Ticket) */ {
 public:
  inline Auth_Ticket() : Auth_Ticket(nullptr) {}
  ~Auth_Ticket() override;
  explicit PROTOBUF_CONSTEXPR Auth_Ticket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Auth_Ticket(const Auth_Ticket& from);
  Auth_Ticket(Auth_Ticket&& from) noexcept
    : Auth_Ticket() {
    *this = ::std::move(from);
  }

  inline Auth_Ticket& operator=(const Auth_Ticket& from) {
    CopyFrom(from);
    return *this;
  }
  inline Auth_Ticket& operator=(Auth_Ticket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Auth_Ticket& default_instance() {
    return *internal_default_instance();
  }
  static inline const Auth_Ticket* internal_default_instance() {
    return reinterpret_cast<const Auth_Ticket*>(
               &_Auth_Ticket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Auth_Ticket& a, Auth_Ticket& b) {
    a.Swap(&b);
  }
  inline void Swap(Auth_Ticket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Auth_Ticket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Auth_Ticket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Auth_Ticket>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Auth_Ticket& from);
  void MergeFrom(const Auth_Ticket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Auth_Ticket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Auth_Ticket";
  }
  protected:
  explicit Auth_Ticket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Auth_Ticket_Types Types;
  static constexpr Types CANCEL =
    Auth_Ticket_Types_CANCEL;
  static inline bool Types_IsValid(int value) {
    return Auth_Ticket_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Auth_Ticket_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Auth_Ticket_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Auth_Ticket_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Auth_Ticket_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Auth_Ticket_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // uint32 number = 1;
  void clear_number();
  uint32_t number() const;
  void set_number(uint32_t value);
  private:
  uint32_t _internal_number() const;
  void _internal_set_number(uint32_t value);
  public:

  // .Auth_Ticket.Types type = 2;
  void clear_type();
  ::Auth_Ticket_Types type() const;
  void set_type(::Auth_Ticket_Types value);
  private:
  ::Auth_Ticket_Types _internal_type() const;
  void _internal_set_type(::Auth_Ticket_Types value);
  public:

  // @@protoc_insertion_point(class_scope:Auth_Ticket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t number_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Friend_Messages final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Friend_Messages) */ {
 public:
  inline Friend_Messages() : Friend_Messages(nullptr) {}
  ~Friend_Messages() override;
  explicit PROTOBUF_CONSTEXPR Friend_Messages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Friend_Messages(const Friend_Messages& from);
  Friend_Messages(Friend_Messages&& from) noexcept
    : Friend_Messages() {
    *this = ::std::move(from);
  }

  inline Friend_Messages& operator=(const Friend_Messages& from) {
    CopyFrom(from);
    return *this;
  }
  inline Friend_Messages& operator=(Friend_Messages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Friend_Messages& default_instance() {
    return *internal_default_instance();
  }
  enum InviteDataCase {
    kLobbyId = 2,
    kConnectStr = 3,
    INVITE_DATA_NOT_SET = 0,
  };

  static inline const Friend_Messages* internal_default_instance() {
    return reinterpret_cast<const Friend_Messages*>(
               &_Friend_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Friend_Messages& a, Friend_Messages& b) {
    a.Swap(&b);
  }
  inline void Swap(Friend_Messages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Friend_Messages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Friend_Messages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Friend_Messages>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Friend_Messages& from);
  void MergeFrom(const Friend_Messages& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Friend_Messages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Friend_Messages";
  }
  protected:
  explicit Friend_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Friend_Messages_Types Types;
  static constexpr Types LOBBY_INVITE =
    Friend_Messages_Types_LOBBY_INVITE;
  static constexpr Types GAME_INVITE =
    Friend_Messages_Types_GAME_INVITE;
  static inline bool Types_IsValid(int value) {
    return Friend_Messages_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Friend_Messages_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Friend_Messages_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Friend_Messages_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Friend_Messages_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Friend_Messages_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kLobbyIdFieldNumber = 2,
    kConnectStrFieldNumber = 3,
  };
  // .Friend_Messages.Types type = 1;
  void clear_type();
  ::Friend_Messages_Types type() const;
  void set_type(::Friend_Messages_Types value);
  private:
  ::Friend_Messages_Types _internal_type() const;
  void _internal_set_type(::Friend_Messages_Types value);
  public:

  // uint64 lobby_id = 2;
  bool has_lobby_id() const;
  private:
  bool _internal_has_lobby_id() const;
  public:
  void clear_lobby_id();
  uint64_t lobby_id() const;
  void set_lobby_id(uint64_t value);
  private:
  uint64_t _internal_lobby_id() const;
  void _internal_set_lobby_id(uint64_t value);
  public:

  // bytes connect_str = 3;
  bool has_connect_str() const;
  private:
  bool _internal_has_connect_str() const;
  public:
  void clear_connect_str();
  const std::string& connect_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connect_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connect_str();
  PROTOBUF_NODISCARD std::string* release_connect_str();
  void set_allocated_connect_str(std::string* connect_str);
  private:
  const std::string& _internal_connect_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connect_str(const std::string& value);
  std::string* _internal_mutable_connect_str();
  public:

  void clear_invite_data();
  InviteDataCase invite_data_case() const;
  // @@protoc_insertion_point(class_scope:Friend_Messages)
 private:
  class _Internal;
  void set_has_lobby_id();
  void set_has_connect_str();

  inline bool has_invite_data() const;
  inline void clear_has_invite_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union InviteDataUnion {
      constexpr InviteDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t lobby_id_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connect_str_;
    } invite_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Steam_Messages final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Steam_Messages) */ {
 public:
  inline Steam_Messages() : Steam_Messages(nullptr) {}
  ~Steam_Messages() override;
  explicit PROTOBUF_CONSTEXPR Steam_Messages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Steam_Messages(const Steam_Messages& from);
  Steam_Messages(Steam_Messages&& from) noexcept
    : Steam_Messages() {
    *this = ::std::move(from);
  }

  inline Steam_Messages& operator=(const Steam_Messages& from) {
    CopyFrom(from);
    return *this;
  }
  inline Steam_Messages& operator=(Steam_Messages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Steam_Messages& default_instance() {
    return *internal_default_instance();
  }
  enum MessageDataCase {
    kMessage = 2,
    MESSAGE_DATA_NOT_SET = 0,
  };

  static inline const Steam_Messages* internal_default_instance() {
    return reinterpret_cast<const Steam_Messages*>(
               &_Steam_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Steam_Messages& a, Steam_Messages& b) {
    a.Swap(&b);
  }
  inline void Swap(Steam_Messages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Steam_Messages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Steam_Messages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Steam_Messages>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Steam_Messages& from);
  void MergeFrom(const Steam_Messages& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Steam_Messages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Steam_Messages";
  }
  protected:
  explicit Steam_Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Steam_Messages_Types Types;
  static constexpr Types FRIEND_CHAT =
    Steam_Messages_Types_FRIEND_CHAT;
  static inline bool Types_IsValid(int value) {
    return Steam_Messages_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    Steam_Messages_Types_Types_MIN;
  static constexpr Types Types_MAX =
    Steam_Messages_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    Steam_Messages_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return Steam_Messages_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return Steam_Messages_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // .Steam_Messages.Types type = 1;
  void clear_type();
  ::Steam_Messages_Types type() const;
  void set_type(::Steam_Messages_Types value);
  private:
  ::Steam_Messages_Types _internal_type() const;
  void _internal_set_type(::Steam_Messages_Types value);
  public:

  // bytes message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  void clear_message_data();
  MessageDataCase message_data_case() const;
  // @@protoc_insertion_point(class_scope:Steam_Messages)
 private:
  class _Internal;
  void set_has_message();

  inline bool has_message_data() const;
  inline void clear_has_message_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union MessageDataUnion {
      constexpr MessageDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    } message_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Common_Message final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Common_Message) */ {
 public:
  inline Common_Message() : Common_Message(nullptr) {}
  ~Common_Message() override;
  explicit PROTOBUF_CONSTEXPR Common_Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Common_Message(const Common_Message& from);
  Common_Message(Common_Message&& from) noexcept
    : Common_Message() {
    *this = ::std::move(from);
  }

  inline Common_Message& operator=(const Common_Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Common_Message& operator=(Common_Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Common_Message& default_instance() {
    return *internal_default_instance();
  }
  enum MessagesCase {
    kAnnounce = 3,
    kLowLevel = 4,
    kLobby = 5,
    kLobbyMessages = 6,
    kNetwork = 7,
    kGameserver = 8,
    kFriend = 9,
    kAuthTicket = 10,
    kFriendMessages = 11,
    kNetworkOld = 12,
    kNetworkingSockets = 13,
    kSteamMessages = 14,
    kNetworkingMessages = 15,
    MESSAGES_NOT_SET = 0,
  };

  static inline const Common_Message* internal_default_instance() {
    return reinterpret_cast<const Common_Message*>(
               &_Common_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Common_Message& a, Common_Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Common_Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Common_Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Common_Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Common_Message>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Common_Message& from);
  void MergeFrom(const Common_Message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Common_Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common_Message";
  }
  protected:
  explicit Common_Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kDestIdFieldNumber = 2,
    kSourceIpFieldNumber = 128,
    kSourcePortFieldNumber = 129,
    kAnnounceFieldNumber = 3,
    kLowLevelFieldNumber = 4,
    kLobbyFieldNumber = 5,
    kLobbyMessagesFieldNumber = 6,
    kNetworkFieldNumber = 7,
    kGameserverFieldNumber = 8,
    kFriendFieldNumber = 9,
    kAuthTicketFieldNumber = 10,
    kFriendMessagesFieldNumber = 11,
    kNetworkOldFieldNumber = 12,
    kNetworkingSocketsFieldNumber = 13,
    kSteamMessagesFieldNumber = 14,
    kNetworkingMessagesFieldNumber = 15,
  };
  // uint64 source_id = 1;
  void clear_source_id();
  uint64_t source_id() const;
  void set_source_id(uint64_t value);
  private:
  uint64_t _internal_source_id() const;
  void _internal_set_source_id(uint64_t value);
  public:

  // uint64 dest_id = 2;
  void clear_dest_id();
  uint64_t dest_id() const;
  void set_dest_id(uint64_t value);
  private:
  uint64_t _internal_dest_id() const;
  void _internal_set_dest_id(uint64_t value);
  public:

  // uint32 source_ip = 128;
  void clear_source_ip();
  uint32_t source_ip() const;
  void set_source_ip(uint32_t value);
  private:
  uint32_t _internal_source_ip() const;
  void _internal_set_source_ip(uint32_t value);
  public:

  // uint32 source_port = 129;
  void clear_source_port();
  uint32_t source_port() const;
  void set_source_port(uint32_t value);
  private:
  uint32_t _internal_source_port() const;
  void _internal_set_source_port(uint32_t value);
  public:

  // .Announce announce = 3;
  bool has_announce() const;
  private:
  bool _internal_has_announce() const;
  public:
  void clear_announce();
  const ::Announce& announce() const;
  PROTOBUF_NODISCARD ::Announce* release_announce();
  ::Announce* mutable_announce();
  void set_allocated_announce(::Announce* announce);
  private:
  const ::Announce& _internal_announce() const;
  ::Announce* _internal_mutable_announce();
  public:
  void unsafe_arena_set_allocated_announce(
      ::Announce* announce);
  ::Announce* unsafe_arena_release_announce();

  // .Low_Level low_level = 4;
  bool has_low_level() const;
  private:
  bool _internal_has_low_level() const;
  public:
  void clear_low_level();
  const ::Low_Level& low_level() const;
  PROTOBUF_NODISCARD ::Low_Level* release_low_level();
  ::Low_Level* mutable_low_level();
  void set_allocated_low_level(::Low_Level* low_level);
  private:
  const ::Low_Level& _internal_low_level() const;
  ::Low_Level* _internal_mutable_low_level();
  public:
  void unsafe_arena_set_allocated_low_level(
      ::Low_Level* low_level);
  ::Low_Level* unsafe_arena_release_low_level();

  // .Lobby lobby = 5;
  bool has_lobby() const;
  private:
  bool _internal_has_lobby() const;
  public:
  void clear_lobby();
  const ::Lobby& lobby() const;
  PROTOBUF_NODISCARD ::Lobby* release_lobby();
  ::Lobby* mutable_lobby();
  void set_allocated_lobby(::Lobby* lobby);
  private:
  const ::Lobby& _internal_lobby() const;
  ::Lobby* _internal_mutable_lobby();
  public:
  void unsafe_arena_set_allocated_lobby(
      ::Lobby* lobby);
  ::Lobby* unsafe_arena_release_lobby();

  // .Lobby_Messages lobby_messages = 6;
  bool has_lobby_messages() const;
  private:
  bool _internal_has_lobby_messages() const;
  public:
  void clear_lobby_messages();
  const ::Lobby_Messages& lobby_messages() const;
  PROTOBUF_NODISCARD ::Lobby_Messages* release_lobby_messages();
  ::Lobby_Messages* mutable_lobby_messages();
  void set_allocated_lobby_messages(::Lobby_Messages* lobby_messages);
  private:
  const ::Lobby_Messages& _internal_lobby_messages() const;
  ::Lobby_Messages* _internal_mutable_lobby_messages();
  public:
  void unsafe_arena_set_allocated_lobby_messages(
      ::Lobby_Messages* lobby_messages);
  ::Lobby_Messages* unsafe_arena_release_lobby_messages();

  // .Network_pb network = 7;
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const ::Network_pb& network() const;
  PROTOBUF_NODISCARD ::Network_pb* release_network();
  ::Network_pb* mutable_network();
  void set_allocated_network(::Network_pb* network);
  private:
  const ::Network_pb& _internal_network() const;
  ::Network_pb* _internal_mutable_network();
  public:
  void unsafe_arena_set_allocated_network(
      ::Network_pb* network);
  ::Network_pb* unsafe_arena_release_network();

  // .Gameserver gameserver = 8;
  bool has_gameserver() const;
  private:
  bool _internal_has_gameserver() const;
  public:
  void clear_gameserver();
  const ::Gameserver& gameserver() const;
  PROTOBUF_NODISCARD ::Gameserver* release_gameserver();
  ::Gameserver* mutable_gameserver();
  void set_allocated_gameserver(::Gameserver* gameserver);
  private:
  const ::Gameserver& _internal_gameserver() const;
  ::Gameserver* _internal_mutable_gameserver();
  public:
  void unsafe_arena_set_allocated_gameserver(
      ::Gameserver* gameserver);
  ::Gameserver* unsafe_arena_release_gameserver();

  // .Friend friend = 9;
  bool has_friend_() const;
  private:
  bool _internal_has_friend_() const;
  public:
  void clear_friend_();
  const ::Friend& friend_() const;
  PROTOBUF_NODISCARD ::Friend* release_friend_();
  ::Friend* mutable_friend_();
  void set_allocated_friend_(::Friend* friend_);
  private:
  const ::Friend& _internal_friend_() const;
  ::Friend* _internal_mutable_friend_();
  public:
  void unsafe_arena_set_allocated_friend_(
      ::Friend* friend_);
  ::Friend* unsafe_arena_release_friend_();

  // .Auth_Ticket auth_ticket = 10;
  bool has_auth_ticket() const;
  private:
  bool _internal_has_auth_ticket() const;
  public:
  void clear_auth_ticket();
  const ::Auth_Ticket& auth_ticket() const;
  PROTOBUF_NODISCARD ::Auth_Ticket* release_auth_ticket();
  ::Auth_Ticket* mutable_auth_ticket();
  void set_allocated_auth_ticket(::Auth_Ticket* auth_ticket);
  private:
  const ::Auth_Ticket& _internal_auth_ticket() const;
  ::Auth_Ticket* _internal_mutable_auth_ticket();
  public:
  void unsafe_arena_set_allocated_auth_ticket(
      ::Auth_Ticket* auth_ticket);
  ::Auth_Ticket* unsafe_arena_release_auth_ticket();

  // .Friend_Messages friend_messages = 11;
  bool has_friend_messages() const;
  private:
  bool _internal_has_friend_messages() const;
  public:
  void clear_friend_messages();
  const ::Friend_Messages& friend_messages() const;
  PROTOBUF_NODISCARD ::Friend_Messages* release_friend_messages();
  ::Friend_Messages* mutable_friend_messages();
  void set_allocated_friend_messages(::Friend_Messages* friend_messages);
  private:
  const ::Friend_Messages& _internal_friend_messages() const;
  ::Friend_Messages* _internal_mutable_friend_messages();
  public:
  void unsafe_arena_set_allocated_friend_messages(
      ::Friend_Messages* friend_messages);
  ::Friend_Messages* unsafe_arena_release_friend_messages();

  // .Network_Old network_old = 12;
  bool has_network_old() const;
  private:
  bool _internal_has_network_old() const;
  public:
  void clear_network_old();
  const ::Network_Old& network_old() const;
  PROTOBUF_NODISCARD ::Network_Old* release_network_old();
  ::Network_Old* mutable_network_old();
  void set_allocated_network_old(::Network_Old* network_old);
  private:
  const ::Network_Old& _internal_network_old() const;
  ::Network_Old* _internal_mutable_network_old();
  public:
  void unsafe_arena_set_allocated_network_old(
      ::Network_Old* network_old);
  ::Network_Old* unsafe_arena_release_network_old();

  // .Networking_Sockets networking_sockets = 13;
  bool has_networking_sockets() const;
  private:
  bool _internal_has_networking_sockets() const;
  public:
  void clear_networking_sockets();
  const ::Networking_Sockets& networking_sockets() const;
  PROTOBUF_NODISCARD ::Networking_Sockets* release_networking_sockets();
  ::Networking_Sockets* mutable_networking_sockets();
  void set_allocated_networking_sockets(::Networking_Sockets* networking_sockets);
  private:
  const ::Networking_Sockets& _internal_networking_sockets() const;
  ::Networking_Sockets* _internal_mutable_networking_sockets();
  public:
  void unsafe_arena_set_allocated_networking_sockets(
      ::Networking_Sockets* networking_sockets);
  ::Networking_Sockets* unsafe_arena_release_networking_sockets();

  // .Steam_Messages steam_messages = 14;
  bool has_steam_messages() const;
  private:
  bool _internal_has_steam_messages() const;
  public:
  void clear_steam_messages();
  const ::Steam_Messages& steam_messages() const;
  PROTOBUF_NODISCARD ::Steam_Messages* release_steam_messages();
  ::Steam_Messages* mutable_steam_messages();
  void set_allocated_steam_messages(::Steam_Messages* steam_messages);
  private:
  const ::Steam_Messages& _internal_steam_messages() const;
  ::Steam_Messages* _internal_mutable_steam_messages();
  public:
  void unsafe_arena_set_allocated_steam_messages(
      ::Steam_Messages* steam_messages);
  ::Steam_Messages* unsafe_arena_release_steam_messages();

  // .Networking_Messages networking_messages = 15;
  bool has_networking_messages() const;
  private:
  bool _internal_has_networking_messages() const;
  public:
  void clear_networking_messages();
  const ::Networking_Messages& networking_messages() const;
  PROTOBUF_NODISCARD ::Networking_Messages* release_networking_messages();
  ::Networking_Messages* mutable_networking_messages();
  void set_allocated_networking_messages(::Networking_Messages* networking_messages);
  private:
  const ::Networking_Messages& _internal_networking_messages() const;
  ::Networking_Messages* _internal_mutable_networking_messages();
  public:
  void unsafe_arena_set_allocated_networking_messages(
      ::Networking_Messages* networking_messages);
  ::Networking_Messages* unsafe_arena_release_networking_messages();

  void clear_messages();
  MessagesCase messages_case() const;
  // @@protoc_insertion_point(class_scope:Common_Message)
 private:
  class _Internal;
  void set_has_announce();
  void set_has_low_level();
  void set_has_lobby();
  void set_has_lobby_messages();
  void set_has_network();
  void set_has_gameserver();
  void set_has_friend_();
  void set_has_auth_ticket();
  void set_has_friend_messages();
  void set_has_network_old();
  void set_has_networking_sockets();
  void set_has_steam_messages();
  void set_has_networking_messages();

  inline bool has_messages() const;
  inline void clear_has_messages();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t source_id_;
    uint64_t dest_id_;
    uint32_t source_ip_;
    uint32_t source_port_;
    union MessagesUnion {
      constexpr MessagesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Announce* announce_;
      ::Low_Level* low_level_;
      ::Lobby* lobby_;
      ::Lobby_Messages* lobby_messages_;
      ::Network_pb* network_;
      ::Gameserver* gameserver_;
      ::Friend* friend__;
      ::Auth_Ticket* auth_ticket_;
      ::Friend_Messages* friend_messages_;
      ::Network_Old* network_old_;
      ::Networking_Sockets* networking_sockets_;
      ::Steam_Messages* steam_messages_;
      ::Networking_Messages* networking_messages_;
    } messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Announce_Other_Peers

// uint64 id = 1;
inline void Announce_Other_Peers::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Announce_Other_Peers::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Announce_Other_Peers::id() const {
  // @@protoc_insertion_point(field_get:Announce.Other_Peers.id)
  return _internal_id();
}
inline void Announce_Other_Peers::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Announce_Other_Peers::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Announce.Other_Peers.id)
}

// uint32 ip = 2;
inline void Announce_Other_Peers::clear_ip() {
  _impl_.ip_ = 0u;
}
inline uint32_t Announce_Other_Peers::_internal_ip() const {
  return _impl_.ip_;
}
inline uint32_t Announce_Other_Peers::ip() const {
  // @@protoc_insertion_point(field_get:Announce.Other_Peers.ip)
  return _internal_ip();
}
inline void Announce_Other_Peers::_internal_set_ip(uint32_t value) {
  
  _impl_.ip_ = value;
}
inline void Announce_Other_Peers::set_ip(uint32_t value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:Announce.Other_Peers.ip)
}

// uint32 udp_port = 3;
inline void Announce_Other_Peers::clear_udp_port() {
  _impl_.udp_port_ = 0u;
}
inline uint32_t Announce_Other_Peers::_internal_udp_port() const {
  return _impl_.udp_port_;
}
inline uint32_t Announce_Other_Peers::udp_port() const {
  // @@protoc_insertion_point(field_get:Announce.Other_Peers.udp_port)
  return _internal_udp_port();
}
inline void Announce_Other_Peers::_internal_set_udp_port(uint32_t value) {
  
  _impl_.udp_port_ = value;
}
inline void Announce_Other_Peers::set_udp_port(uint32_t value) {
  _internal_set_udp_port(value);
  // @@protoc_insertion_point(field_set:Announce.Other_Peers.udp_port)
}

// uint32 appid = 4;
inline void Announce_Other_Peers::clear_appid() {
  _impl_.appid_ = 0u;
}
inline uint32_t Announce_Other_Peers::_internal_appid() const {
  return _impl_.appid_;
}
inline uint32_t Announce_Other_Peers::appid() const {
  // @@protoc_insertion_point(field_get:Announce.Other_Peers.appid)
  return _internal_appid();
}
inline void Announce_Other_Peers::_internal_set_appid(uint32_t value) {
  
  _impl_.appid_ = value;
}
inline void Announce_Other_Peers::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Announce.Other_Peers.appid)
}

// -------------------------------------------------------------------

// Announce

// .Announce.Types type = 1;
inline void Announce::clear_type() {
  _impl_.type_ = 0;
}
inline ::Announce_Types Announce::_internal_type() const {
  return static_cast< ::Announce_Types >(_impl_.type_);
}
inline ::Announce_Types Announce::type() const {
  // @@protoc_insertion_point(field_get:Announce.type)
  return _internal_type();
}
inline void Announce::_internal_set_type(::Announce_Types value) {
  
  _impl_.type_ = value;
}
inline void Announce::set_type(::Announce_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Announce.type)
}

// repeated uint64 ids = 2;
inline int Announce::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int Announce::ids_size() const {
  return _internal_ids_size();
}
inline void Announce::clear_ids() {
  _impl_.ids_.Clear();
}
inline uint64_t Announce::_internal_ids(int index) const {
  return _impl_.ids_.Get(index);
}
inline uint64_t Announce::ids(int index) const {
  // @@protoc_insertion_point(field_get:Announce.ids)
  return _internal_ids(index);
}
inline void Announce::set_ids(int index, uint64_t value) {
  _impl_.ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Announce.ids)
}
inline void Announce::_internal_add_ids(uint64_t value) {
  _impl_.ids_.Add(value);
}
inline void Announce::add_ids(uint64_t value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:Announce.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Announce::_internal_ids() const {
  return _impl_.ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Announce::ids() const {
  // @@protoc_insertion_point(field_list:Announce.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Announce::_internal_mutable_ids() {
  return &_impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Announce::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:Announce.ids)
  return _internal_mutable_ids();
}

// uint32 tcp_port = 3;
inline void Announce::clear_tcp_port() {
  _impl_.tcp_port_ = 0u;
}
inline uint32_t Announce::_internal_tcp_port() const {
  return _impl_.tcp_port_;
}
inline uint32_t Announce::tcp_port() const {
  // @@protoc_insertion_point(field_get:Announce.tcp_port)
  return _internal_tcp_port();
}
inline void Announce::_internal_set_tcp_port(uint32_t value) {
  
  _impl_.tcp_port_ = value;
}
inline void Announce::set_tcp_port(uint32_t value) {
  _internal_set_tcp_port(value);
  // @@protoc_insertion_point(field_set:Announce.tcp_port)
}

// repeated .Announce.Other_Peers peers = 4;
inline int Announce::_internal_peers_size() const {
  return _impl_.peers_.size();
}
inline int Announce::peers_size() const {
  return _internal_peers_size();
}
inline void Announce::clear_peers() {
  _impl_.peers_.Clear();
}
inline ::Announce_Other_Peers* Announce::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:Announce.peers)
  return _impl_.peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers >*
Announce::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:Announce.peers)
  return &_impl_.peers_;
}
inline const ::Announce_Other_Peers& Announce::_internal_peers(int index) const {
  return _impl_.peers_.Get(index);
}
inline const ::Announce_Other_Peers& Announce::peers(int index) const {
  // @@protoc_insertion_point(field_get:Announce.peers)
  return _internal_peers(index);
}
inline ::Announce_Other_Peers* Announce::_internal_add_peers() {
  return _impl_.peers_.Add();
}
inline ::Announce_Other_Peers* Announce::add_peers() {
  ::Announce_Other_Peers* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:Announce.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Announce_Other_Peers >&
Announce::peers() const {
  // @@protoc_insertion_point(field_list:Announce.peers)
  return _impl_.peers_;
}

// uint32 appid = 5;
inline void Announce::clear_appid() {
  _impl_.appid_ = 0u;
}
inline uint32_t Announce::_internal_appid() const {
  return _impl_.appid_;
}
inline uint32_t Announce::appid() const {
  // @@protoc_insertion_point(field_get:Announce.appid)
  return _internal_appid();
}
inline void Announce::_internal_set_appid(uint32_t value) {
  
  _impl_.appid_ = value;
}
inline void Announce::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Announce.appid)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Lobby_Member

// uint64 id = 1;
inline void Lobby_Member::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Lobby_Member::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Lobby_Member::id() const {
  // @@protoc_insertion_point(field_get:Lobby.Member.id)
  return _internal_id();
}
inline void Lobby_Member::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Lobby_Member::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Lobby.Member.id)
}

// map<string, bytes> values = 2;
inline int Lobby_Member::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Lobby_Member::values_size() const {
  return _internal_values_size();
}
inline void Lobby_Member::clear_values() {
  _impl_.values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby_Member::_internal_values() const {
  return _impl_.values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby_Member::values() const {
  // @@protoc_insertion_point(field_map:Lobby.Member.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby_Member::_internal_mutable_values() {
  return _impl_.values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby_Member::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:Lobby.Member.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Lobby_Gameserver

// uint64 id = 1;
inline void Lobby_Gameserver::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Lobby_Gameserver::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Lobby_Gameserver::id() const {
  // @@protoc_insertion_point(field_get:Lobby.Gameserver.id)
  return _internal_id();
}
inline void Lobby_Gameserver::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Lobby_Gameserver::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Lobby.Gameserver.id)
}

// uint32 ip = 2;
inline void Lobby_Gameserver::clear_ip() {
  _impl_.ip_ = 0u;
}
inline uint32_t Lobby_Gameserver::_internal_ip() const {
  return _impl_.ip_;
}
inline uint32_t Lobby_Gameserver::ip() const {
  // @@protoc_insertion_point(field_get:Lobby.Gameserver.ip)
  return _internal_ip();
}
inline void Lobby_Gameserver::_internal_set_ip(uint32_t value) {
  
  _impl_.ip_ = value;
}
inline void Lobby_Gameserver::set_ip(uint32_t value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:Lobby.Gameserver.ip)
}

// uint32 port = 3;
inline void Lobby_Gameserver::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t Lobby_Gameserver::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t Lobby_Gameserver::port() const {
  // @@protoc_insertion_point(field_get:Lobby.Gameserver.port)
  return _internal_port();
}
inline void Lobby_Gameserver::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void Lobby_Gameserver::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Lobby.Gameserver.port)
}

// -------------------------------------------------------------------

// Lobby

// uint64 room_id = 1;
inline void Lobby::clear_room_id() {
  _impl_.room_id_ = uint64_t{0u};
}
inline uint64_t Lobby::_internal_room_id() const {
  return _impl_.room_id_;
}
inline uint64_t Lobby::room_id() const {
  // @@protoc_insertion_point(field_get:Lobby.room_id)
  return _internal_room_id();
}
inline void Lobby::_internal_set_room_id(uint64_t value) {
  
  _impl_.room_id_ = value;
}
inline void Lobby::set_room_id(uint64_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Lobby.room_id)
}

// uint64 owner = 2;
inline void Lobby::clear_owner() {
  _impl_.owner_ = uint64_t{0u};
}
inline uint64_t Lobby::_internal_owner() const {
  return _impl_.owner_;
}
inline uint64_t Lobby::owner() const {
  // @@protoc_insertion_point(field_get:Lobby.owner)
  return _internal_owner();
}
inline void Lobby::_internal_set_owner(uint64_t value) {
  
  _impl_.owner_ = value;
}
inline void Lobby::set_owner(uint64_t value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:Lobby.owner)
}

// map<string, bytes> values = 3;
inline int Lobby::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Lobby::values_size() const {
  return _internal_values_size();
}
inline void Lobby::clear_values() {
  _impl_.values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby::_internal_values() const {
  return _impl_.values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby::values() const {
  // @@protoc_insertion_point(field_map:Lobby.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby::_internal_mutable_values() {
  return _impl_.values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:Lobby.values)
  return _internal_mutable_values();
}

// repeated .Lobby.Member members = 4;
inline int Lobby::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int Lobby::members_size() const {
  return _internal_members_size();
}
inline void Lobby::clear_members() {
  _impl_.members_.Clear();
}
inline ::Lobby_Member* Lobby::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:Lobby.members)
  return _impl_.members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member >*
Lobby::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:Lobby.members)
  return &_impl_.members_;
}
inline const ::Lobby_Member& Lobby::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const ::Lobby_Member& Lobby::members(int index) const {
  // @@protoc_insertion_point(field_get:Lobby.members)
  return _internal_members(index);
}
inline ::Lobby_Member* Lobby::_internal_add_members() {
  return _impl_.members_.Add();
}
inline ::Lobby_Member* Lobby::add_members() {
  ::Lobby_Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:Lobby.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Lobby_Member >&
Lobby::members() const {
  // @@protoc_insertion_point(field_list:Lobby.members)
  return _impl_.members_;
}

// .Lobby.Gameserver gameserver = 5;
inline bool Lobby::_internal_has_gameserver() const {
  return this != internal_default_instance() && _impl_.gameserver_ != nullptr;
}
inline bool Lobby::has_gameserver() const {
  return _internal_has_gameserver();
}
inline void Lobby::clear_gameserver() {
  if (GetArenaForAllocation() == nullptr && _impl_.gameserver_ != nullptr) {
    delete _impl_.gameserver_;
  }
  _impl_.gameserver_ = nullptr;
}
inline const ::Lobby_Gameserver& Lobby::_internal_gameserver() const {
  const ::Lobby_Gameserver* p = _impl_.gameserver_;
  return p != nullptr ? *p : reinterpret_cast<const ::Lobby_Gameserver&>(
      ::_Lobby_Gameserver_default_instance_);
}
inline const ::Lobby_Gameserver& Lobby::gameserver() const {
  // @@protoc_insertion_point(field_get:Lobby.gameserver)
  return _internal_gameserver();
}
inline void Lobby::unsafe_arena_set_allocated_gameserver(
    ::Lobby_Gameserver* gameserver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gameserver_);
  }
  _impl_.gameserver_ = gameserver;
  if (gameserver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Lobby.gameserver)
}
inline ::Lobby_Gameserver* Lobby::release_gameserver() {
  
  ::Lobby_Gameserver* temp = _impl_.gameserver_;
  _impl_.gameserver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Lobby_Gameserver* Lobby::unsafe_arena_release_gameserver() {
  // @@protoc_insertion_point(field_release:Lobby.gameserver)
  
  ::Lobby_Gameserver* temp = _impl_.gameserver_;
  _impl_.gameserver_ = nullptr;
  return temp;
}
inline ::Lobby_Gameserver* Lobby::_internal_mutable_gameserver() {
  
  if (_impl_.gameserver_ == nullptr) {
    auto* p = CreateMaybeMessage<::Lobby_Gameserver>(GetArenaForAllocation());
    _impl_.gameserver_ = p;
  }
  return _impl_.gameserver_;
}
inline ::Lobby_Gameserver* Lobby::mutable_gameserver() {
  ::Lobby_Gameserver* _msg = _internal_mutable_gameserver();
  // @@protoc_insertion_point(field_mutable:Lobby.gameserver)
  return _msg;
}
inline void Lobby::set_allocated_gameserver(::Lobby_Gameserver* gameserver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gameserver_;
  }
  if (gameserver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gameserver);
    if (message_arena != submessage_arena) {
      gameserver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameserver, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gameserver_ = gameserver;
  // @@protoc_insertion_point(field_set_allocated:Lobby.gameserver)
}

// uint32 member_limit = 6;
inline void Lobby::clear_member_limit() {
  _impl_.member_limit_ = 0u;
}
inline uint32_t Lobby::_internal_member_limit() const {
  return _impl_.member_limit_;
}
inline uint32_t Lobby::member_limit() const {
  // @@protoc_insertion_point(field_get:Lobby.member_limit)
  return _internal_member_limit();
}
inline void Lobby::_internal_set_member_limit(uint32_t value) {
  
  _impl_.member_limit_ = value;
}
inline void Lobby::set_member_limit(uint32_t value) {
  _internal_set_member_limit(value);
  // @@protoc_insertion_point(field_set:Lobby.member_limit)
}

// uint32 type = 7;
inline void Lobby::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t Lobby::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t Lobby::type() const {
  // @@protoc_insertion_point(field_get:Lobby.type)
  return _internal_type();
}
inline void Lobby::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void Lobby::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Lobby.type)
}

// bool joinable = 8;
inline void Lobby::clear_joinable() {
  _impl_.joinable_ = false;
}
inline bool Lobby::_internal_joinable() const {
  return _impl_.joinable_;
}
inline bool Lobby::joinable() const {
  // @@protoc_insertion_point(field_get:Lobby.joinable)
  return _internal_joinable();
}
inline void Lobby::_internal_set_joinable(bool value) {
  
  _impl_.joinable_ = value;
}
inline void Lobby::set_joinable(bool value) {
  _internal_set_joinable(value);
  // @@protoc_insertion_point(field_set:Lobby.joinable)
}

// uint32 appid = 9;
inline void Lobby::clear_appid() {
  _impl_.appid_ = 0u;
}
inline uint32_t Lobby::_internal_appid() const {
  return _impl_.appid_;
}
inline uint32_t Lobby::appid() const {
  // @@protoc_insertion_point(field_get:Lobby.appid)
  return _internal_appid();
}
inline void Lobby::_internal_set_appid(uint32_t value) {
  
  _impl_.appid_ = value;
}
inline void Lobby::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Lobby.appid)
}

// bool deleted = 32;
inline void Lobby::clear_deleted() {
  _impl_.deleted_ = false;
}
inline bool Lobby::_internal_deleted() const {
  return _impl_.deleted_;
}
inline bool Lobby::deleted() const {
  // @@protoc_insertion_point(field_get:Lobby.deleted)
  return _internal_deleted();
}
inline void Lobby::_internal_set_deleted(bool value) {
  
  _impl_.deleted_ = value;
}
inline void Lobby::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:Lobby.deleted)
}

// uint64 time_deleted = 33;
inline void Lobby::clear_time_deleted() {
  _impl_.time_deleted_ = uint64_t{0u};
}
inline uint64_t Lobby::_internal_time_deleted() const {
  return _impl_.time_deleted_;
}
inline uint64_t Lobby::time_deleted() const {
  // @@protoc_insertion_point(field_get:Lobby.time_deleted)
  return _internal_time_deleted();
}
inline void Lobby::_internal_set_time_deleted(uint64_t value) {
  
  _impl_.time_deleted_ = value;
}
inline void Lobby::set_time_deleted(uint64_t value) {
  _internal_set_time_deleted(value);
  // @@protoc_insertion_point(field_set:Lobby.time_deleted)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Lobby_Messages

// uint64 id = 1;
inline void Lobby_Messages::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Lobby_Messages::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Lobby_Messages::id() const {
  // @@protoc_insertion_point(field_get:Lobby_Messages.id)
  return _internal_id();
}
inline void Lobby_Messages::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Lobby_Messages::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Lobby_Messages.id)
}

// .Lobby_Messages.Types type = 2;
inline void Lobby_Messages::clear_type() {
  _impl_.type_ = 0;
}
inline ::Lobby_Messages_Types Lobby_Messages::_internal_type() const {
  return static_cast< ::Lobby_Messages_Types >(_impl_.type_);
}
inline ::Lobby_Messages_Types Lobby_Messages::type() const {
  // @@protoc_insertion_point(field_get:Lobby_Messages.type)
  return _internal_type();
}
inline void Lobby_Messages::_internal_set_type(::Lobby_Messages_Types value) {
  
  _impl_.type_ = value;
}
inline void Lobby_Messages::set_type(::Lobby_Messages_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Lobby_Messages.type)
}

// uint64 idata = 3;
inline void Lobby_Messages::clear_idata() {
  _impl_.idata_ = uint64_t{0u};
}
inline uint64_t Lobby_Messages::_internal_idata() const {
  return _impl_.idata_;
}
inline uint64_t Lobby_Messages::idata() const {
  // @@protoc_insertion_point(field_get:Lobby_Messages.idata)
  return _internal_idata();
}
inline void Lobby_Messages::_internal_set_idata(uint64_t value) {
  
  _impl_.idata_ = value;
}
inline void Lobby_Messages::set_idata(uint64_t value) {
  _internal_set_idata(value);
  // @@protoc_insertion_point(field_set:Lobby_Messages.idata)
}

// bytes bdata = 4;
inline void Lobby_Messages::clear_bdata() {
  _impl_.bdata_.ClearToEmpty();
}
inline const std::string& Lobby_Messages::bdata() const {
  // @@protoc_insertion_point(field_get:Lobby_Messages.bdata)
  return _internal_bdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lobby_Messages::set_bdata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bdata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Lobby_Messages.bdata)
}
inline std::string* Lobby_Messages::mutable_bdata() {
  std::string* _s = _internal_mutable_bdata();
  // @@protoc_insertion_point(field_mutable:Lobby_Messages.bdata)
  return _s;
}
inline const std::string& Lobby_Messages::_internal_bdata() const {
  return _impl_.bdata_.Get();
}
inline void Lobby_Messages::_internal_set_bdata(const std::string& value) {
  
  _impl_.bdata_.Set(value, GetArenaForAllocation());
}
inline std::string* Lobby_Messages::_internal_mutable_bdata() {
  
  return _impl_.bdata_.Mutable(GetArenaForAllocation());
}
inline std::string* Lobby_Messages::release_bdata() {
  // @@protoc_insertion_point(field_release:Lobby_Messages.bdata)
  return _impl_.bdata_.Release();
}
inline void Lobby_Messages::set_allocated_bdata(std::string* bdata) {
  if (bdata != nullptr) {
    
  } else {
    
  }
  _impl_.bdata_.SetAllocated(bdata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bdata_.IsDefault()) {
    _impl_.bdata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Lobby_Messages.bdata)
}

// map<string, bytes> map = 5;
inline int Lobby_Messages::_internal_map_size() const {
  return _impl_.map_.size();
}
inline int Lobby_Messages::map_size() const {
  return _internal_map_size();
}
inline void Lobby_Messages::clear_map() {
  _impl_.map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby_Messages::_internal_map() const {
  return _impl_.map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lobby_Messages::map() const {
  // @@protoc_insertion_point(field_map:Lobby_Messages.map)
  return _internal_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby_Messages::_internal_mutable_map() {
  return _impl_.map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lobby_Messages::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:Lobby_Messages.map)
  return _internal_mutable_map();
}

// -------------------------------------------------------------------

// Low_Level

// .Low_Level.Types type = 1;
inline void Low_Level::clear_type() {
  _impl_.type_ = 0;
}
inline ::Low_Level_Types Low_Level::_internal_type() const {
  return static_cast< ::Low_Level_Types >(_impl_.type_);
}
inline ::Low_Level_Types Low_Level::type() const {
  // @@protoc_insertion_point(field_get:Low_Level.type)
  return _internal_type();
}
inline void Low_Level::_internal_set_type(::Low_Level_Types value) {
  
  _impl_.type_ = value;
}
inline void Low_Level::set_type(::Low_Level_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Low_Level.type)
}

// -------------------------------------------------------------------

// Network_pb

// uint32 channel = 1;
inline void Network_pb::clear_channel() {
  _impl_.channel_ = 0u;
}
inline uint32_t Network_pb::_internal_channel() const {
  return _impl_.channel_;
}
inline uint32_t Network_pb::channel() const {
  // @@protoc_insertion_point(field_get:Network_pb.channel)
  return _internal_channel();
}
inline void Network_pb::_internal_set_channel(uint32_t value) {
  
  _impl_.channel_ = value;
}
inline void Network_pb::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:Network_pb.channel)
}

// bytes data = 2;
inline void Network_pb::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Network_pb::data() const {
  // @@protoc_insertion_point(field_get:Network_pb.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network_pb::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Network_pb.data)
}
inline std::string* Network_pb::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Network_pb.data)
  return _s;
}
inline const std::string& Network_pb::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Network_pb::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Network_pb::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Network_pb::release_data() {
  // @@protoc_insertion_point(field_release:Network_pb.data)
  return _impl_.data_.Release();
}
inline void Network_pb::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Network_pb.data)
}

// .Network_pb.Types type = 3;
inline void Network_pb::clear_type() {
  _impl_.type_ = 0;
}
inline ::Network_pb_Types Network_pb::_internal_type() const {
  return static_cast< ::Network_pb_Types >(_impl_.type_);
}
inline ::Network_pb_Types Network_pb::type() const {
  // @@protoc_insertion_point(field_get:Network_pb.type)
  return _internal_type();
}
inline void Network_pb::_internal_set_type(::Network_pb_Types value) {
  
  _impl_.type_ = value;
}
inline void Network_pb::set_type(::Network_pb_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Network_pb.type)
}

// bool processed = 128;
inline void Network_pb::clear_processed() {
  _impl_.processed_ = false;
}
inline bool Network_pb::_internal_processed() const {
  return _impl_.processed_;
}
inline bool Network_pb::processed() const {
  // @@protoc_insertion_point(field_get:Network_pb.processed)
  return _internal_processed();
}
inline void Network_pb::_internal_set_processed(bool value) {
  
  _impl_.processed_ = value;
}
inline void Network_pb::set_processed(bool value) {
  _internal_set_processed(value);
  // @@protoc_insertion_point(field_set:Network_pb.processed)
}

// uint64 time_processed = 129;
inline void Network_pb::clear_time_processed() {
  _impl_.time_processed_ = uint64_t{0u};
}
inline uint64_t Network_pb::_internal_time_processed() const {
  return _impl_.time_processed_;
}
inline uint64_t Network_pb::time_processed() const {
  // @@protoc_insertion_point(field_get:Network_pb.time_processed)
  return _internal_time_processed();
}
inline void Network_pb::_internal_set_time_processed(uint64_t value) {
  
  _impl_.time_processed_ = value;
}
inline void Network_pb::set_time_processed(uint64_t value) {
  _internal_set_time_processed(value);
  // @@protoc_insertion_point(field_set:Network_pb.time_processed)
}

// -------------------------------------------------------------------

// Network_Old

// .Network_Old.Types type = 1;
inline void Network_Old::clear_type() {
  _impl_.type_ = 0;
}
inline ::Network_Old_Types Network_Old::_internal_type() const {
  return static_cast< ::Network_Old_Types >(_impl_.type_);
}
inline ::Network_Old_Types Network_Old::type() const {
  // @@protoc_insertion_point(field_get:Network_Old.type)
  return _internal_type();
}
inline void Network_Old::_internal_set_type(::Network_Old_Types value) {
  
  _impl_.type_ = value;
}
inline void Network_Old::set_type(::Network_Old_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Network_Old.type)
}

// uint64 connection_id = 2;
inline void Network_Old::clear_connection_id() {
  _impl_.connection_id_ = uint64_t{0u};
}
inline uint64_t Network_Old::_internal_connection_id() const {
  return _impl_.connection_id_;
}
inline uint64_t Network_Old::connection_id() const {
  // @@protoc_insertion_point(field_get:Network_Old.connection_id)
  return _internal_connection_id();
}
inline void Network_Old::_internal_set_connection_id(uint64_t value) {
  
  _impl_.connection_id_ = value;
}
inline void Network_Old::set_connection_id(uint64_t value) {
  _internal_set_connection_id(value);
  // @@protoc_insertion_point(field_set:Network_Old.connection_id)
}

// uint64 connection_id_from = 3;
inline void Network_Old::clear_connection_id_from() {
  _impl_.connection_id_from_ = uint64_t{0u};
}
inline uint64_t Network_Old::_internal_connection_id_from() const {
  return _impl_.connection_id_from_;
}
inline uint64_t Network_Old::connection_id_from() const {
  // @@protoc_insertion_point(field_get:Network_Old.connection_id_from)
  return _internal_connection_id_from();
}
inline void Network_Old::_internal_set_connection_id_from(uint64_t value) {
  
  _impl_.connection_id_from_ = value;
}
inline void Network_Old::set_connection_id_from(uint64_t value) {
  _internal_set_connection_id_from(value);
  // @@protoc_insertion_point(field_set:Network_Old.connection_id_from)
}

// uint32 port = 4;
inline void Network_Old::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t Network_Old::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t Network_Old::port() const {
  // @@protoc_insertion_point(field_get:Network_Old.port)
  return _internal_port();
}
inline void Network_Old::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void Network_Old::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Network_Old.port)
}

// bytes data = 5;
inline void Network_Old::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Network_Old::data() const {
  // @@protoc_insertion_point(field_get:Network_Old.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network_Old::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Network_Old.data)
}
inline std::string* Network_Old::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Network_Old.data)
  return _s;
}
inline const std::string& Network_Old::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Network_Old::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Network_Old::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Network_Old::release_data() {
  // @@protoc_insertion_point(field_release:Network_Old.data)
  return _impl_.data_.Release();
}
inline void Network_Old::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Network_Old.data)
}

// -------------------------------------------------------------------

// Networking_Sockets

// .Networking_Sockets.Types type = 1;
inline void Networking_Sockets::clear_type() {
  _impl_.type_ = 0;
}
inline ::Networking_Sockets_Types Networking_Sockets::_internal_type() const {
  return static_cast< ::Networking_Sockets_Types >(_impl_.type_);
}
inline ::Networking_Sockets_Types Networking_Sockets::type() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.type)
  return _internal_type();
}
inline void Networking_Sockets::_internal_set_type(::Networking_Sockets_Types value) {
  
  _impl_.type_ = value;
}
inline void Networking_Sockets::set_type(::Networking_Sockets_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Networking_Sockets.type)
}

// int32 virtual_port = 2;
inline void Networking_Sockets::clear_virtual_port() {
  _impl_.virtual_port_ = 0;
}
inline int32_t Networking_Sockets::_internal_virtual_port() const {
  return _impl_.virtual_port_;
}
inline int32_t Networking_Sockets::virtual_port() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.virtual_port)
  return _internal_virtual_port();
}
inline void Networking_Sockets::_internal_set_virtual_port(int32_t value) {
  
  _impl_.virtual_port_ = value;
}
inline void Networking_Sockets::set_virtual_port(int32_t value) {
  _internal_set_virtual_port(value);
  // @@protoc_insertion_point(field_set:Networking_Sockets.virtual_port)
}

// int32 real_port = 6;
inline void Networking_Sockets::clear_real_port() {
  _impl_.real_port_ = 0;
}
inline int32_t Networking_Sockets::_internal_real_port() const {
  return _impl_.real_port_;
}
inline int32_t Networking_Sockets::real_port() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.real_port)
  return _internal_real_port();
}
inline void Networking_Sockets::_internal_set_real_port(int32_t value) {
  
  _impl_.real_port_ = value;
}
inline void Networking_Sockets::set_real_port(int32_t value) {
  _internal_set_real_port(value);
  // @@protoc_insertion_point(field_set:Networking_Sockets.real_port)
}

// uint64 connection_id = 3;
inline void Networking_Sockets::clear_connection_id() {
  _impl_.connection_id_ = uint64_t{0u};
}
inline uint64_t Networking_Sockets::_internal_connection_id() const {
  return _impl_.connection_id_;
}
inline uint64_t Networking_Sockets::connection_id() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.connection_id)
  return _internal_connection_id();
}
inline void Networking_Sockets::_internal_set_connection_id(uint64_t value) {
  
  _impl_.connection_id_ = value;
}
inline void Networking_Sockets::set_connection_id(uint64_t value) {
  _internal_set_connection_id(value);
  // @@protoc_insertion_point(field_set:Networking_Sockets.connection_id)
}

// uint64 connection_id_from = 4;
inline void Networking_Sockets::clear_connection_id_from() {
  _impl_.connection_id_from_ = uint64_t{0u};
}
inline uint64_t Networking_Sockets::_internal_connection_id_from() const {
  return _impl_.connection_id_from_;
}
inline uint64_t Networking_Sockets::connection_id_from() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.connection_id_from)
  return _internal_connection_id_from();
}
inline void Networking_Sockets::_internal_set_connection_id_from(uint64_t value) {
  
  _impl_.connection_id_from_ = value;
}
inline void Networking_Sockets::set_connection_id_from(uint64_t value) {
  _internal_set_connection_id_from(value);
  // @@protoc_insertion_point(field_set:Networking_Sockets.connection_id_from)
}

// bytes data = 5;
inline void Networking_Sockets::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Networking_Sockets::data() const {
  // @@protoc_insertion_point(field_get:Networking_Sockets.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Networking_Sockets::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Networking_Sockets.data)
}
inline std::string* Networking_Sockets::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Networking_Sockets.data)
  return _s;
}
inline const std::string& Networking_Sockets::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Networking_Sockets::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Networking_Sockets::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Networking_Sockets::release_data() {
  // @@protoc_insertion_point(field_release:Networking_Sockets.data)
  return _impl_.data_.Release();
}
inline void Networking_Sockets::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Networking_Sockets.data)
}

// -------------------------------------------------------------------

// Networking_Messages

// .Networking_Messages.Types type = 1;
inline void Networking_Messages::clear_type() {
  _impl_.type_ = 0;
}
inline ::Networking_Messages_Types Networking_Messages::_internal_type() const {
  return static_cast< ::Networking_Messages_Types >(_impl_.type_);
}
inline ::Networking_Messages_Types Networking_Messages::type() const {
  // @@protoc_insertion_point(field_get:Networking_Messages.type)
  return _internal_type();
}
inline void Networking_Messages::_internal_set_type(::Networking_Messages_Types value) {
  
  _impl_.type_ = value;
}
inline void Networking_Messages::set_type(::Networking_Messages_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Networking_Messages.type)
}

// uint32 channel = 2;
inline void Networking_Messages::clear_channel() {
  _impl_.channel_ = 0u;
}
inline uint32_t Networking_Messages::_internal_channel() const {
  return _impl_.channel_;
}
inline uint32_t Networking_Messages::channel() const {
  // @@protoc_insertion_point(field_get:Networking_Messages.channel)
  return _internal_channel();
}
inline void Networking_Messages::_internal_set_channel(uint32_t value) {
  
  _impl_.channel_ = value;
}
inline void Networking_Messages::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:Networking_Messages.channel)
}

// uint32 id_from = 3;
inline void Networking_Messages::clear_id_from() {
  _impl_.id_from_ = 0u;
}
inline uint32_t Networking_Messages::_internal_id_from() const {
  return _impl_.id_from_;
}
inline uint32_t Networking_Messages::id_from() const {
  // @@protoc_insertion_point(field_get:Networking_Messages.id_from)
  return _internal_id_from();
}
inline void Networking_Messages::_internal_set_id_from(uint32_t value) {
  
  _impl_.id_from_ = value;
}
inline void Networking_Messages::set_id_from(uint32_t value) {
  _internal_set_id_from(value);
  // @@protoc_insertion_point(field_set:Networking_Messages.id_from)
}

// bytes data = 5;
inline void Networking_Messages::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Networking_Messages::data() const {
  // @@protoc_insertion_point(field_get:Networking_Messages.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Networking_Messages::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Networking_Messages.data)
}
inline std::string* Networking_Messages::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Networking_Messages.data)
  return _s;
}
inline const std::string& Networking_Messages::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Networking_Messages::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Networking_Messages::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Networking_Messages::release_data() {
  // @@protoc_insertion_point(field_release:Networking_Messages.data)
  return _impl_.data_.Release();
}
inline void Networking_Messages::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Networking_Messages.data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Gameserver

// uint64 id = 1;
inline void Gameserver::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Gameserver::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Gameserver::id() const {
  // @@protoc_insertion_point(field_get:Gameserver.id)
  return _internal_id();
}
inline void Gameserver::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Gameserver::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Gameserver.id)
}

// bytes game_description = 2;
inline void Gameserver::clear_game_description() {
  _impl_.game_description_.ClearToEmpty();
}
inline const std::string& Gameserver::game_description() const {
  // @@protoc_insertion_point(field_get:Gameserver.game_description)
  return _internal_game_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_game_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_description_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.game_description)
}
inline std::string* Gameserver::mutable_game_description() {
  std::string* _s = _internal_mutable_game_description();
  // @@protoc_insertion_point(field_mutable:Gameserver.game_description)
  return _s;
}
inline const std::string& Gameserver::_internal_game_description() const {
  return _impl_.game_description_.Get();
}
inline void Gameserver::_internal_set_game_description(const std::string& value) {
  
  _impl_.game_description_.Set(value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_game_description() {
  
  return _impl_.game_description_.Mutable(GetArenaForAllocation());
}
inline std::string* Gameserver::release_game_description() {
  // @@protoc_insertion_point(field_release:Gameserver.game_description)
  return _impl_.game_description_.Release();
}
inline void Gameserver::set_allocated_game_description(std::string* game_description) {
  if (game_description != nullptr) {
    
  } else {
    
  }
  _impl_.game_description_.SetAllocated(game_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_description_.IsDefault()) {
    _impl_.game_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Gameserver.game_description)
}

// bytes mod_dir = 3;
inline void Gameserver::clear_mod_dir() {
  _impl_.mod_dir_.ClearToEmpty();
}
inline const std::string& Gameserver::mod_dir() const {
  // @@protoc_insertion_point(field_get:Gameserver.mod_dir)
  return _internal_mod_dir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_mod_dir(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mod_dir_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.mod_dir)
}
inline std::string* Gameserver::mutable_mod_dir() {
  std::string* _s = _internal_mutable_mod_dir();
  // @@protoc_insertion_point(field_mutable:Gameserver.mod_dir)
  return _s;
}
inline const std::string& Gameserver::_internal_mod_dir() const {
  return _impl_.mod_dir_.Get();
}
inline void Gameserver::_internal_set_mod_dir(const std::string& value) {
  
  _impl_.mod_dir_.Set(value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_mod_dir() {
  
  return _impl_.mod_dir_.Mutable(GetArenaForAllocation());
}
inline std::string* Gameserver::release_mod_dir() {
  // @@protoc_insertion_point(field_release:Gameserver.mod_dir)
  return _impl_.mod_dir_.Release();
}
inline void Gameserver::set_allocated_mod_dir(std::string* mod_dir) {
  if (mod_dir != nullptr) {
    
  } else {
    
  }
  _impl_.mod_dir_.SetAllocated(mod_dir, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mod_dir_.IsDefault()) {
    _impl_.mod_dir_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Gameserver.mod_dir)
}

// bool dedicated_server = 4;
inline void Gameserver::clear_dedicated_server() {
  _impl_.dedicated_server_ = false;
}
inline bool Gameserver::_internal_dedicated_server() const {
  return _impl_.dedicated_server_;
}
inline bool Gameserver::dedicated_server() const {
  // @@protoc_insertion_point(field_get:Gameserver.dedicated_server)
  return _internal_dedicated_server();
}
inline void Gameserver::_internal_set_dedicated_server(bool value) {
  
  _impl_.dedicated_server_ = value;
}
inline void Gameserver::set_dedicated_server(bool value) {
  _internal_set_dedicated_server(value);
  // @@protoc_insertion_point(field_set:Gameserver.dedicated_server)
}

// uint32 max_player_count = 5;
inline void Gameserver::clear_max_player_count() {
  _impl_.max_player_count_ = 0u;
}
inline uint32_t Gameserver::_internal_max_player_count() const {
  return _impl_.max_player_count_;
}
inline uint32_t Gameserver::max_player_count() const {
  // @@protoc_insertion_point(field_get:Gameserver.max_player_count)
  return _internal_max_player_count();
}
inline void Gameserver::_internal_set_max_player_count(uint32_t value) {
  
  _impl_.max_player_count_ = value;
}
inline void Gameserver::set_max_player_count(uint32_t value) {
  _internal_set_max_player_count(value);
  // @@protoc_insertion_point(field_set:Gameserver.max_player_count)
}

// uint32 bot_player_count = 6;
inline void Gameserver::clear_bot_player_count() {
  _impl_.bot_player_count_ = 0u;
}
inline uint32_t Gameserver::_internal_bot_player_count() const {
  return _impl_.bot_player_count_;
}
inline uint32_t Gameserver::bot_player_count() const {
  // @@protoc_insertion_point(field_get:Gameserver.bot_player_count)
  return _internal_bot_player_count();
}
inline void Gameserver::_internal_set_bot_player_count(uint32_t value) {
  
  _impl_.bot_player_count_ = value;
}
inline void Gameserver::set_bot_player_count(uint32_t value) {
  _internal_set_bot_player_count(value);
  // @@protoc_insertion_point(field_set:Gameserver.bot_player_count)
}

// bytes server_name = 7;
inline void Gameserver::clear_server_name() {
  _impl_.server_name_.ClearToEmpty();
}
inline const std::string& Gameserver::server_name() const {
  // @@protoc_insertion_point(field_get:Gameserver.server_name)
  return _internal_server_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_server_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.server_name)
}
inline std::string* Gameserver::mutable_server_name() {
  std::string* _s = _internal_mutable_server_name();
  // @@protoc_insertion_point(field_mutable:Gameserver.server_name)
  return _s;
}
inline const std::string& Gameserver::_internal_server_name() const {
  return _impl_.server_name_.Get();
}
inline void Gameserver::_internal_set_server_name(const std::string& value) {
  
  _impl_.server_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_server_name() {
  
  return _impl_.server_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Gameserver::release_server_name() {
  // @@protoc_insertion_point(field_release:Gameserver.server_name)
  return _impl_.server_name_.Release();
}
inline void Gameserver::set_allocated_server_name(std::string* server_name) {
  if (server_name != nullptr) {
    
  } else {
    
  }
  _impl_.server_name_.SetAllocated(server_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_name_.IsDefault()) {
    _impl_.server_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Gameserver.server_name)
}

// bytes map_name = 8;
inline void Gameserver::clear_map_name() {
  _impl_.map_name_.ClearToEmpty();
}
inline const std::string& Gameserver::map_name() const {
  // @@protoc_insertion_point(field_get:Gameserver.map_name)
  return _internal_map_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_map_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.map_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.map_name)
}
inline std::string* Gameserver::mutable_map_name() {
  std::string* _s = _internal_mutable_map_name();
  // @@protoc_insertion_point(field_mutable:Gameserver.map_name)
  return _s;
}
inline const std::string& Gameserver::_internal_map_name() const {
  return _impl_.map_name_.Get();
}
inline void Gameserver::_internal_set_map_name(const std::string& value) {
  
  _impl_.map_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_map_name() {
  
  return _impl_.map_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Gameserver::release_map_name() {
  // @@protoc_insertion_point(field_release:Gameserver.map_name)
  return _impl_.map_name_.Release();
}
inline void Gameserver::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    
  } else {
    
  }
  _impl_.map_name_.SetAllocated(map_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_name_.IsDefault()) {
    _impl_.map_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Gameserver.map_name)
}

// bool password_protected = 9;
inline void Gameserver::clear_password_protected() {
  _impl_.password_protected_ = false;
}
inline bool Gameserver::_internal_password_protected() const {
  return _impl_.password_protected_;
}
inline bool Gameserver::password_protected() const {
  // @@protoc_insertion_point(field_get:Gameserver.password_protected)
  return _internal_password_protected();
}
inline void Gameserver::_internal_set_password_protected(bool value) {
  
  _impl_.password_protected_ = value;
}
inline void Gameserver::set_password_protected(bool value) {
  _internal_set_password_protected(value);
  // @@protoc_insertion_point(field_set:Gameserver.password_protected)
}

// uint32 spectator_port = 10;
inline void Gameserver::clear_spectator_port() {
  _impl_.spectator_port_ = 0u;
}
inline uint32_t Gameserver::_internal_spectator_port() const {
  return _impl_.spectator_port_;
}
inline uint32_t Gameserver::spectator_port() const {
  // @@protoc_insertion_point(field_get:Gameserver.spectator_port)
  return _internal_spectator_port();
}
inline void Gameserver::_internal_set_spectator_port(uint32_t value) {
  
  _impl_.spectator_port_ = value;
}
inline void Gameserver::set_spectator_port(uint32_t value) {
  _internal_set_spectator_port(value);
  // @@protoc_insertion_point(field_set:Gameserver.spectator_port)
}

// bytes spectator_server_name = 11;
inline void Gameserver::clear_spectator_server_name() {
  _impl_.spectator_server_name_.ClearToEmpty();
}
inline const std::string& Gameserver::spectator_server_name() const {
  // @@protoc_insertion_point(field_get:Gameserver.spectator_server_name)
  return _internal_spectator_server_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_spectator_server_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spectator_server_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.spectator_server_name)
}
inline std::string* Gameserver::mutable_spectator_server_name() {
  std::string* _s = _internal_mutable_spectator_server_name();
  // @@protoc_insertion_point(field_mutable:Gameserver.spectator_server_name)
  return _s;
}
inline const std::string& Gameserver::_internal_spectator_server_name() const {
  return _impl_.spectator_server_name_.Get();
}
inline void Gameserver::_internal_set_spectator_server_name(const std::string& value) {
  
  _impl_.spectator_server_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_spectator_server_name() {
  
  return _impl_.spectator_server_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Gameserver::release_spectator_server_name() {
  // @@protoc_insertion_point(field_release:Gameserver.spectator_server_name)
  return _impl_.spectator_server_name_.Release();
}
inline void Gameserver::set_allocated_spectator_server_name(std::string* spectator_server_name) {
  if (spectator_server_name != nullptr) {
    
  } else {
    
  }
  _impl_.spectator_server_name_.SetAllocated(spectator_server_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spectator_server_name_.IsDefault()) {
    _impl_.spectator_server_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Gameserver.spectator_server_name)
}

// map<string, bytes> values = 12;
inline int Gameserver::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Gameserver::values_size() const {
  return _internal_values_size();
}
inline void Gameserver::clear_values() {
  _impl_.values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Gameserver::_internal_values() const {
  return _impl_.values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Gameserver::values() const {
  // @@protoc_insertion_point(field_map:Gameserver.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Gameserver::_internal_mutable_values() {
  return _impl_.values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Gameserver::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:Gameserver.values)
  return _internal_mutable_values();
}

// bytes tags = 13;
inline void Gameserver::clear_tags() {
  _impl_.tags_.ClearToEmpty();
}
inline const std::string& Gameserver::tags() const {
  // @@protoc_insertion_point(field_get:Gameserver.tags)
  return _internal_tags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_tags(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tags_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.tags)
}
inline std::string* Gameserver::mutable_tags() {
  std::string* _s = _internal_mutable_tags();
  // @@protoc_insertion_point(field_mutable:Gameserver.tags)
  return _s;
}
inline const std::string& Gameserver::_internal_tags() const {
  return _impl_.tags_.Get();
}
inline void Gameserver::_internal_set_tags(const std::string& value) {
  
  _impl_.tags_.Set(value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_tags() {
  
  return _impl_.tags_.Mutable(GetArenaForAllocation());
}
inline std::string* Gameserver::release_tags() {
  // @@protoc_insertion_point(field_release:Gameserver.tags)
  return _impl_.tags_.Release();
}
inline void Gameserver::set_allocated_tags(std::string* tags) {
  if (tags != nullptr) {
    
  } else {
    
  }
  _impl_.tags_.SetAllocated(tags, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tags_.IsDefault()) {
    _impl_.tags_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Gameserver.tags)
}

// bytes gamedata = 14;
inline void Gameserver::clear_gamedata() {
  _impl_.gamedata_.ClearToEmpty();
}
inline const std::string& Gameserver::gamedata() const {
  // @@protoc_insertion_point(field_get:Gameserver.gamedata)
  return _internal_gamedata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_gamedata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gamedata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.gamedata)
}
inline std::string* Gameserver::mutable_gamedata() {
  std::string* _s = _internal_mutable_gamedata();
  // @@protoc_insertion_point(field_mutable:Gameserver.gamedata)
  return _s;
}
inline const std::string& Gameserver::_internal_gamedata() const {
  return _impl_.gamedata_.Get();
}
inline void Gameserver::_internal_set_gamedata(const std::string& value) {
  
  _impl_.gamedata_.Set(value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_gamedata() {
  
  return _impl_.gamedata_.Mutable(GetArenaForAllocation());
}
inline std::string* Gameserver::release_gamedata() {
  // @@protoc_insertion_point(field_release:Gameserver.gamedata)
  return _impl_.gamedata_.Release();
}
inline void Gameserver::set_allocated_gamedata(std::string* gamedata) {
  if (gamedata != nullptr) {
    
  } else {
    
  }
  _impl_.gamedata_.SetAllocated(gamedata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gamedata_.IsDefault()) {
    _impl_.gamedata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Gameserver.gamedata)
}

// bytes region = 15;
inline void Gameserver::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& Gameserver::region() const {
  // @@protoc_insertion_point(field_get:Gameserver.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.region)
}
inline std::string* Gameserver::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:Gameserver.region)
  return _s;
}
inline const std::string& Gameserver::_internal_region() const {
  return _impl_.region_.Get();
}
inline void Gameserver::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* Gameserver::release_region() {
  // @@protoc_insertion_point(field_release:Gameserver.region)
  return _impl_.region_.Release();
}
inline void Gameserver::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Gameserver.region)
}

// bytes product = 16;
inline void Gameserver::clear_product() {
  _impl_.product_.ClearToEmpty();
}
inline const std::string& Gameserver::product() const {
  // @@protoc_insertion_point(field_get:Gameserver.product)
  return _internal_product();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gameserver::set_product(ArgT0&& arg0, ArgT... args) {
 
 _impl_.product_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Gameserver.product)
}
inline std::string* Gameserver::mutable_product() {
  std::string* _s = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:Gameserver.product)
  return _s;
}
inline const std::string& Gameserver::_internal_product() const {
  return _impl_.product_.Get();
}
inline void Gameserver::_internal_set_product(const std::string& value) {
  
  _impl_.product_.Set(value, GetArenaForAllocation());
}
inline std::string* Gameserver::_internal_mutable_product() {
  
  return _impl_.product_.Mutable(GetArenaForAllocation());
}
inline std::string* Gameserver::release_product() {
  // @@protoc_insertion_point(field_release:Gameserver.product)
  return _impl_.product_.Release();
}
inline void Gameserver::set_allocated_product(std::string* product) {
  if (product != nullptr) {
    
  } else {
    
  }
  _impl_.product_.SetAllocated(product, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_.IsDefault()) {
    _impl_.product_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Gameserver.product)
}

// bool secure = 17;
inline void Gameserver::clear_secure() {
  _impl_.secure_ = false;
}
inline bool Gameserver::_internal_secure() const {
  return _impl_.secure_;
}
inline bool Gameserver::secure() const {
  // @@protoc_insertion_point(field_get:Gameserver.secure)
  return _internal_secure();
}
inline void Gameserver::_internal_set_secure(bool value) {
  
  _impl_.secure_ = value;
}
inline void Gameserver::set_secure(bool value) {
  _internal_set_secure(value);
  // @@protoc_insertion_point(field_set:Gameserver.secure)
}

// uint32 num_players = 18;
inline void Gameserver::clear_num_players() {
  _impl_.num_players_ = 0u;
}
inline uint32_t Gameserver::_internal_num_players() const {
  return _impl_.num_players_;
}
inline uint32_t Gameserver::num_players() const {
  // @@protoc_insertion_point(field_get:Gameserver.num_players)
  return _internal_num_players();
}
inline void Gameserver::_internal_set_num_players(uint32_t value) {
  
  _impl_.num_players_ = value;
}
inline void Gameserver::set_num_players(uint32_t value) {
  _internal_set_num_players(value);
  // @@protoc_insertion_point(field_set:Gameserver.num_players)
}

// uint32 version = 19;
inline void Gameserver::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t Gameserver::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t Gameserver::version() const {
  // @@protoc_insertion_point(field_get:Gameserver.version)
  return _internal_version();
}
inline void Gameserver::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void Gameserver::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:Gameserver.version)
}

// uint32 ip = 32;
inline void Gameserver::clear_ip() {
  _impl_.ip_ = 0u;
}
inline uint32_t Gameserver::_internal_ip() const {
  return _impl_.ip_;
}
inline uint32_t Gameserver::ip() const {
  // @@protoc_insertion_point(field_get:Gameserver.ip)
  return _internal_ip();
}
inline void Gameserver::_internal_set_ip(uint32_t value) {
  
  _impl_.ip_ = value;
}
inline void Gameserver::set_ip(uint32_t value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:Gameserver.ip)
}

// uint32 port = 33;
inline void Gameserver::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t Gameserver::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t Gameserver::port() const {
  // @@protoc_insertion_point(field_get:Gameserver.port)
  return _internal_port();
}
inline void Gameserver::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void Gameserver::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Gameserver.port)
}

// uint32 query_port = 34;
inline void Gameserver::clear_query_port() {
  _impl_.query_port_ = 0u;
}
inline uint32_t Gameserver::_internal_query_port() const {
  return _impl_.query_port_;
}
inline uint32_t Gameserver::query_port() const {
  // @@protoc_insertion_point(field_get:Gameserver.query_port)
  return _internal_query_port();
}
inline void Gameserver::_internal_set_query_port(uint32_t value) {
  
  _impl_.query_port_ = value;
}
inline void Gameserver::set_query_port(uint32_t value) {
  _internal_set_query_port(value);
  // @@protoc_insertion_point(field_set:Gameserver.query_port)
}

// uint32 appid = 35;
inline void Gameserver::clear_appid() {
  _impl_.appid_ = 0u;
}
inline uint32_t Gameserver::_internal_appid() const {
  return _impl_.appid_;
}
inline uint32_t Gameserver::appid() const {
  // @@protoc_insertion_point(field_get:Gameserver.appid)
  return _internal_appid();
}
inline void Gameserver::_internal_set_appid(uint32_t value) {
  
  _impl_.appid_ = value;
}
inline void Gameserver::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Gameserver.appid)
}

// bool offline = 48;
inline void Gameserver::clear_offline() {
  _impl_.offline_ = false;
}
inline bool Gameserver::_internal_offline() const {
  return _impl_.offline_;
}
inline bool Gameserver::offline() const {
  // @@protoc_insertion_point(field_get:Gameserver.offline)
  return _internal_offline();
}
inline void Gameserver::_internal_set_offline(bool value) {
  
  _impl_.offline_ = value;
}
inline void Gameserver::set_offline(bool value) {
  _internal_set_offline(value);
  // @@protoc_insertion_point(field_set:Gameserver.offline)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Friend

// uint64 id = 1;
inline void Friend::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Friend::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Friend::id() const {
  // @@protoc_insertion_point(field_get:Friend.id)
  return _internal_id();
}
inline void Friend::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Friend::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Friend.id)
}

// bytes name = 2;
inline void Friend::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Friend::name() const {
  // @@protoc_insertion_point(field_get:Friend.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Friend::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Friend.name)
}
inline std::string* Friend::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Friend.name)
  return _s;
}
inline const std::string& Friend::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Friend::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Friend::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Friend::release_name() {
  // @@protoc_insertion_point(field_release:Friend.name)
  return _impl_.name_.Release();
}
inline void Friend::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Friend.name)
}

// map<string, bytes> rich_presence = 3;
inline int Friend::_internal_rich_presence_size() const {
  return _impl_.rich_presence_.size();
}
inline int Friend::rich_presence_size() const {
  return _internal_rich_presence_size();
}
inline void Friend::clear_rich_presence() {
  _impl_.rich_presence_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Friend::_internal_rich_presence() const {
  return _impl_.rich_presence_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Friend::rich_presence() const {
  // @@protoc_insertion_point(field_map:Friend.rich_presence)
  return _internal_rich_presence();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Friend::_internal_mutable_rich_presence() {
  return _impl_.rich_presence_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Friend::mutable_rich_presence() {
  // @@protoc_insertion_point(field_mutable_map:Friend.rich_presence)
  return _internal_mutable_rich_presence();
}

// uint32 appid = 4;
inline void Friend::clear_appid() {
  _impl_.appid_ = 0u;
}
inline uint32_t Friend::_internal_appid() const {
  return _impl_.appid_;
}
inline uint32_t Friend::appid() const {
  // @@protoc_insertion_point(field_get:Friend.appid)
  return _internal_appid();
}
inline void Friend::_internal_set_appid(uint32_t value) {
  
  _impl_.appid_ = value;
}
inline void Friend::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:Friend.appid)
}

// uint64 lobby_id = 5;
inline void Friend::clear_lobby_id() {
  _impl_.lobby_id_ = uint64_t{0u};
}
inline uint64_t Friend::_internal_lobby_id() const {
  return _impl_.lobby_id_;
}
inline uint64_t Friend::lobby_id() const {
  // @@protoc_insertion_point(field_get:Friend.lobby_id)
  return _internal_lobby_id();
}
inline void Friend::_internal_set_lobby_id(uint64_t value) {
  
  _impl_.lobby_id_ = value;
}
inline void Friend::set_lobby_id(uint64_t value) {
  _internal_set_lobby_id(value);
  // @@protoc_insertion_point(field_set:Friend.lobby_id)
}

// -------------------------------------------------------------------

// Auth_Ticket

// uint32 number = 1;
inline void Auth_Ticket::clear_number() {
  _impl_.number_ = 0u;
}
inline uint32_t Auth_Ticket::_internal_number() const {
  return _impl_.number_;
}
inline uint32_t Auth_Ticket::number() const {
  // @@protoc_insertion_point(field_get:Auth_Ticket.number)
  return _internal_number();
}
inline void Auth_Ticket::_internal_set_number(uint32_t value) {
  
  _impl_.number_ = value;
}
inline void Auth_Ticket::set_number(uint32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:Auth_Ticket.number)
}

// .Auth_Ticket.Types type = 2;
inline void Auth_Ticket::clear_type() {
  _impl_.type_ = 0;
}
inline ::Auth_Ticket_Types Auth_Ticket::_internal_type() const {
  return static_cast< ::Auth_Ticket_Types >(_impl_.type_);
}
inline ::Auth_Ticket_Types Auth_Ticket::type() const {
  // @@protoc_insertion_point(field_get:Auth_Ticket.type)
  return _internal_type();
}
inline void Auth_Ticket::_internal_set_type(::Auth_Ticket_Types value) {
  
  _impl_.type_ = value;
}
inline void Auth_Ticket::set_type(::Auth_Ticket_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Auth_Ticket.type)
}

// -------------------------------------------------------------------

// Friend_Messages

// .Friend_Messages.Types type = 1;
inline void Friend_Messages::clear_type() {
  _impl_.type_ = 0;
}
inline ::Friend_Messages_Types Friend_Messages::_internal_type() const {
  return static_cast< ::Friend_Messages_Types >(_impl_.type_);
}
inline ::Friend_Messages_Types Friend_Messages::type() const {
  // @@protoc_insertion_point(field_get:Friend_Messages.type)
  return _internal_type();
}
inline void Friend_Messages::_internal_set_type(::Friend_Messages_Types value) {
  
  _impl_.type_ = value;
}
inline void Friend_Messages::set_type(::Friend_Messages_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Friend_Messages.type)
}

// uint64 lobby_id = 2;
inline bool Friend_Messages::_internal_has_lobby_id() const {
  return invite_data_case() == kLobbyId;
}
inline bool Friend_Messages::has_lobby_id() const {
  return _internal_has_lobby_id();
}
inline void Friend_Messages::set_has_lobby_id() {
  _impl_._oneof_case_[0] = kLobbyId;
}
inline void Friend_Messages::clear_lobby_id() {
  if (_internal_has_lobby_id()) {
    _impl_.invite_data_.lobby_id_ = uint64_t{0u};
    clear_has_invite_data();
  }
}
inline uint64_t Friend_Messages::_internal_lobby_id() const {
  if (_internal_has_lobby_id()) {
    return _impl_.invite_data_.lobby_id_;
  }
  return uint64_t{0u};
}
inline void Friend_Messages::_internal_set_lobby_id(uint64_t value) {
  if (!_internal_has_lobby_id()) {
    clear_invite_data();
    set_has_lobby_id();
  }
  _impl_.invite_data_.lobby_id_ = value;
}
inline uint64_t Friend_Messages::lobby_id() const {
  // @@protoc_insertion_point(field_get:Friend_Messages.lobby_id)
  return _internal_lobby_id();
}
inline void Friend_Messages::set_lobby_id(uint64_t value) {
  _internal_set_lobby_id(value);
  // @@protoc_insertion_point(field_set:Friend_Messages.lobby_id)
}

// bytes connect_str = 3;
inline bool Friend_Messages::_internal_has_connect_str() const {
  return invite_data_case() == kConnectStr;
}
inline bool Friend_Messages::has_connect_str() const {
  return _internal_has_connect_str();
}
inline void Friend_Messages::set_has_connect_str() {
  _impl_._oneof_case_[0] = kConnectStr;
}
inline void Friend_Messages::clear_connect_str() {
  if (_internal_has_connect_str()) {
    _impl_.invite_data_.connect_str_.Destroy();
    clear_has_invite_data();
  }
}
inline const std::string& Friend_Messages::connect_str() const {
  // @@protoc_insertion_point(field_get:Friend_Messages.connect_str)
  return _internal_connect_str();
}
template <typename ArgT0, typename... ArgT>
inline void Friend_Messages::set_connect_str(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_connect_str()) {
    clear_invite_data();
    set_has_connect_str();
    _impl_.invite_data_.connect_str_.InitDefault();
  }
  _impl_.invite_data_.connect_str_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Friend_Messages.connect_str)
}
inline std::string* Friend_Messages::mutable_connect_str() {
  std::string* _s = _internal_mutable_connect_str();
  // @@protoc_insertion_point(field_mutable:Friend_Messages.connect_str)
  return _s;
}
inline const std::string& Friend_Messages::_internal_connect_str() const {
  if (_internal_has_connect_str()) {
    return _impl_.invite_data_.connect_str_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Friend_Messages::_internal_set_connect_str(const std::string& value) {
  if (!_internal_has_connect_str()) {
    clear_invite_data();
    set_has_connect_str();
    _impl_.invite_data_.connect_str_.InitDefault();
  }
  _impl_.invite_data_.connect_str_.Set(value, GetArenaForAllocation());
}
inline std::string* Friend_Messages::_internal_mutable_connect_str() {
  if (!_internal_has_connect_str()) {
    clear_invite_data();
    set_has_connect_str();
    _impl_.invite_data_.connect_str_.InitDefault();
  }
  return _impl_.invite_data_.connect_str_.Mutable(      GetArenaForAllocation());
}
inline std::string* Friend_Messages::release_connect_str() {
  // @@protoc_insertion_point(field_release:Friend_Messages.connect_str)
  if (_internal_has_connect_str()) {
    clear_has_invite_data();
    return _impl_.invite_data_.connect_str_.Release();
  } else {
    return nullptr;
  }
}
inline void Friend_Messages::set_allocated_connect_str(std::string* connect_str) {
  if (has_invite_data()) {
    clear_invite_data();
  }
  if (connect_str != nullptr) {
    set_has_connect_str();
    _impl_.invite_data_.connect_str_.InitAllocated(connect_str, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:Friend_Messages.connect_str)
}

inline bool Friend_Messages::has_invite_data() const {
  return invite_data_case() != INVITE_DATA_NOT_SET;
}
inline void Friend_Messages::clear_has_invite_data() {
  _impl_._oneof_case_[0] = INVITE_DATA_NOT_SET;
}
inline Friend_Messages::InviteDataCase Friend_Messages::invite_data_case() const {
  return Friend_Messages::InviteDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Steam_Messages

// .Steam_Messages.Types type = 1;
inline void Steam_Messages::clear_type() {
  _impl_.type_ = 0;
}
inline ::Steam_Messages_Types Steam_Messages::_internal_type() const {
  return static_cast< ::Steam_Messages_Types >(_impl_.type_);
}
inline ::Steam_Messages_Types Steam_Messages::type() const {
  // @@protoc_insertion_point(field_get:Steam_Messages.type)
  return _internal_type();
}
inline void Steam_Messages::_internal_set_type(::Steam_Messages_Types value) {
  
  _impl_.type_ = value;
}
inline void Steam_Messages::set_type(::Steam_Messages_Types value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Steam_Messages.type)
}

// bytes message = 2;
inline bool Steam_Messages::_internal_has_message() const {
  return message_data_case() == kMessage;
}
inline bool Steam_Messages::has_message() const {
  return _internal_has_message();
}
inline void Steam_Messages::set_has_message() {
  _impl_._oneof_case_[0] = kMessage;
}
inline void Steam_Messages::clear_message() {
  if (_internal_has_message()) {
    _impl_.message_data_.message_.Destroy();
    clear_has_message_data();
  }
}
inline const std::string& Steam_Messages::message() const {
  // @@protoc_insertion_point(field_get:Steam_Messages.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline void Steam_Messages::set_message(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_message()) {
    clear_message_data();
    set_has_message();
    _impl_.message_data_.message_.InitDefault();
  }
  _impl_.message_data_.message_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Steam_Messages.message)
}
inline std::string* Steam_Messages::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Steam_Messages.message)
  return _s;
}
inline const std::string& Steam_Messages::_internal_message() const {
  if (_internal_has_message()) {
    return _impl_.message_data_.message_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Steam_Messages::_internal_set_message(const std::string& value) {
  if (!_internal_has_message()) {
    clear_message_data();
    set_has_message();
    _impl_.message_data_.message_.InitDefault();
  }
  _impl_.message_data_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Steam_Messages::_internal_mutable_message() {
  if (!_internal_has_message()) {
    clear_message_data();
    set_has_message();
    _impl_.message_data_.message_.InitDefault();
  }
  return _impl_.message_data_.message_.Mutable(      GetArenaForAllocation());
}
inline std::string* Steam_Messages::release_message() {
  // @@protoc_insertion_point(field_release:Steam_Messages.message)
  if (_internal_has_message()) {
    clear_has_message_data();
    return _impl_.message_data_.message_.Release();
  } else {
    return nullptr;
  }
}
inline void Steam_Messages::set_allocated_message(std::string* message) {
  if (has_message_data()) {
    clear_message_data();
  }
  if (message != nullptr) {
    set_has_message();
    _impl_.message_data_.message_.InitAllocated(message, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:Steam_Messages.message)
}

inline bool Steam_Messages::has_message_data() const {
  return message_data_case() != MESSAGE_DATA_NOT_SET;
}
inline void Steam_Messages::clear_has_message_data() {
  _impl_._oneof_case_[0] = MESSAGE_DATA_NOT_SET;
}
inline Steam_Messages::MessageDataCase Steam_Messages::message_data_case() const {
  return Steam_Messages::MessageDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Common_Message

// uint64 source_id = 1;
inline void Common_Message::clear_source_id() {
  _impl_.source_id_ = uint64_t{0u};
}
inline uint64_t Common_Message::_internal_source_id() const {
  return _impl_.source_id_;
}
inline uint64_t Common_Message::source_id() const {
  // @@protoc_insertion_point(field_get:Common_Message.source_id)
  return _internal_source_id();
}
inline void Common_Message::_internal_set_source_id(uint64_t value) {
  
  _impl_.source_id_ = value;
}
inline void Common_Message::set_source_id(uint64_t value) {
  _internal_set_source_id(value);
  // @@protoc_insertion_point(field_set:Common_Message.source_id)
}

// uint64 dest_id = 2;
inline void Common_Message::clear_dest_id() {
  _impl_.dest_id_ = uint64_t{0u};
}
inline uint64_t Common_Message::_internal_dest_id() const {
  return _impl_.dest_id_;
}
inline uint64_t Common_Message::dest_id() const {
  // @@protoc_insertion_point(field_get:Common_Message.dest_id)
  return _internal_dest_id();
}
inline void Common_Message::_internal_set_dest_id(uint64_t value) {
  
  _impl_.dest_id_ = value;
}
inline void Common_Message::set_dest_id(uint64_t value) {
  _internal_set_dest_id(value);
  // @@protoc_insertion_point(field_set:Common_Message.dest_id)
}

// .Announce announce = 3;
inline bool Common_Message::_internal_has_announce() const {
  return messages_case() == kAnnounce;
}
inline bool Common_Message::has_announce() const {
  return _internal_has_announce();
}
inline void Common_Message::set_has_announce() {
  _impl_._oneof_case_[0] = kAnnounce;
}
inline void Common_Message::clear_announce() {
  if (_internal_has_announce()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.announce_;
    }
    clear_has_messages();
  }
}
inline ::Announce* Common_Message::release_announce() {
  // @@protoc_insertion_point(field_release:Common_Message.announce)
  if (_internal_has_announce()) {
    clear_has_messages();
    ::Announce* temp = _impl_.messages_.announce_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.announce_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Announce& Common_Message::_internal_announce() const {
  return _internal_has_announce()
      ? *_impl_.messages_.announce_
      : reinterpret_cast< ::Announce&>(::_Announce_default_instance_);
}
inline const ::Announce& Common_Message::announce() const {
  // @@protoc_insertion_point(field_get:Common_Message.announce)
  return _internal_announce();
}
inline ::Announce* Common_Message::unsafe_arena_release_announce() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.announce)
  if (_internal_has_announce()) {
    clear_has_messages();
    ::Announce* temp = _impl_.messages_.announce_;
    _impl_.messages_.announce_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_announce(::Announce* announce) {
  clear_messages();
  if (announce) {
    set_has_announce();
    _impl_.messages_.announce_ = announce;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.announce)
}
inline ::Announce* Common_Message::_internal_mutable_announce() {
  if (!_internal_has_announce()) {
    clear_messages();
    set_has_announce();
    _impl_.messages_.announce_ = CreateMaybeMessage< ::Announce >(GetArenaForAllocation());
  }
  return _impl_.messages_.announce_;
}
inline ::Announce* Common_Message::mutable_announce() {
  ::Announce* _msg = _internal_mutable_announce();
  // @@protoc_insertion_point(field_mutable:Common_Message.announce)
  return _msg;
}

// .Low_Level low_level = 4;
inline bool Common_Message::_internal_has_low_level() const {
  return messages_case() == kLowLevel;
}
inline bool Common_Message::has_low_level() const {
  return _internal_has_low_level();
}
inline void Common_Message::set_has_low_level() {
  _impl_._oneof_case_[0] = kLowLevel;
}
inline void Common_Message::clear_low_level() {
  if (_internal_has_low_level()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.low_level_;
    }
    clear_has_messages();
  }
}
inline ::Low_Level* Common_Message::release_low_level() {
  // @@protoc_insertion_point(field_release:Common_Message.low_level)
  if (_internal_has_low_level()) {
    clear_has_messages();
    ::Low_Level* temp = _impl_.messages_.low_level_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.low_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Low_Level& Common_Message::_internal_low_level() const {
  return _internal_has_low_level()
      ? *_impl_.messages_.low_level_
      : reinterpret_cast< ::Low_Level&>(::_Low_Level_default_instance_);
}
inline const ::Low_Level& Common_Message::low_level() const {
  // @@protoc_insertion_point(field_get:Common_Message.low_level)
  return _internal_low_level();
}
inline ::Low_Level* Common_Message::unsafe_arena_release_low_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.low_level)
  if (_internal_has_low_level()) {
    clear_has_messages();
    ::Low_Level* temp = _impl_.messages_.low_level_;
    _impl_.messages_.low_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_low_level(::Low_Level* low_level) {
  clear_messages();
  if (low_level) {
    set_has_low_level();
    _impl_.messages_.low_level_ = low_level;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.low_level)
}
inline ::Low_Level* Common_Message::_internal_mutable_low_level() {
  if (!_internal_has_low_level()) {
    clear_messages();
    set_has_low_level();
    _impl_.messages_.low_level_ = CreateMaybeMessage< ::Low_Level >(GetArenaForAllocation());
  }
  return _impl_.messages_.low_level_;
}
inline ::Low_Level* Common_Message::mutable_low_level() {
  ::Low_Level* _msg = _internal_mutable_low_level();
  // @@protoc_insertion_point(field_mutable:Common_Message.low_level)
  return _msg;
}

// .Lobby lobby = 5;
inline bool Common_Message::_internal_has_lobby() const {
  return messages_case() == kLobby;
}
inline bool Common_Message::has_lobby() const {
  return _internal_has_lobby();
}
inline void Common_Message::set_has_lobby() {
  _impl_._oneof_case_[0] = kLobby;
}
inline void Common_Message::clear_lobby() {
  if (_internal_has_lobby()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.lobby_;
    }
    clear_has_messages();
  }
}
inline ::Lobby* Common_Message::release_lobby() {
  // @@protoc_insertion_point(field_release:Common_Message.lobby)
  if (_internal_has_lobby()) {
    clear_has_messages();
    ::Lobby* temp = _impl_.messages_.lobby_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.lobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Lobby& Common_Message::_internal_lobby() const {
  return _internal_has_lobby()
      ? *_impl_.messages_.lobby_
      : reinterpret_cast< ::Lobby&>(::_Lobby_default_instance_);
}
inline const ::Lobby& Common_Message::lobby() const {
  // @@protoc_insertion_point(field_get:Common_Message.lobby)
  return _internal_lobby();
}
inline ::Lobby* Common_Message::unsafe_arena_release_lobby() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.lobby)
  if (_internal_has_lobby()) {
    clear_has_messages();
    ::Lobby* temp = _impl_.messages_.lobby_;
    _impl_.messages_.lobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_lobby(::Lobby* lobby) {
  clear_messages();
  if (lobby) {
    set_has_lobby();
    _impl_.messages_.lobby_ = lobby;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.lobby)
}
inline ::Lobby* Common_Message::_internal_mutable_lobby() {
  if (!_internal_has_lobby()) {
    clear_messages();
    set_has_lobby();
    _impl_.messages_.lobby_ = CreateMaybeMessage< ::Lobby >(GetArenaForAllocation());
  }
  return _impl_.messages_.lobby_;
}
inline ::Lobby* Common_Message::mutable_lobby() {
  ::Lobby* _msg = _internal_mutable_lobby();
  // @@protoc_insertion_point(field_mutable:Common_Message.lobby)
  return _msg;
}

// .Lobby_Messages lobby_messages = 6;
inline bool Common_Message::_internal_has_lobby_messages() const {
  return messages_case() == kLobbyMessages;
}
inline bool Common_Message::has_lobby_messages() const {
  return _internal_has_lobby_messages();
}
inline void Common_Message::set_has_lobby_messages() {
  _impl_._oneof_case_[0] = kLobbyMessages;
}
inline void Common_Message::clear_lobby_messages() {
  if (_internal_has_lobby_messages()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.lobby_messages_;
    }
    clear_has_messages();
  }
}
inline ::Lobby_Messages* Common_Message::release_lobby_messages() {
  // @@protoc_insertion_point(field_release:Common_Message.lobby_messages)
  if (_internal_has_lobby_messages()) {
    clear_has_messages();
    ::Lobby_Messages* temp = _impl_.messages_.lobby_messages_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.lobby_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Lobby_Messages& Common_Message::_internal_lobby_messages() const {
  return _internal_has_lobby_messages()
      ? *_impl_.messages_.lobby_messages_
      : reinterpret_cast< ::Lobby_Messages&>(::_Lobby_Messages_default_instance_);
}
inline const ::Lobby_Messages& Common_Message::lobby_messages() const {
  // @@protoc_insertion_point(field_get:Common_Message.lobby_messages)
  return _internal_lobby_messages();
}
inline ::Lobby_Messages* Common_Message::unsafe_arena_release_lobby_messages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.lobby_messages)
  if (_internal_has_lobby_messages()) {
    clear_has_messages();
    ::Lobby_Messages* temp = _impl_.messages_.lobby_messages_;
    _impl_.messages_.lobby_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_lobby_messages(::Lobby_Messages* lobby_messages) {
  clear_messages();
  if (lobby_messages) {
    set_has_lobby_messages();
    _impl_.messages_.lobby_messages_ = lobby_messages;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.lobby_messages)
}
inline ::Lobby_Messages* Common_Message::_internal_mutable_lobby_messages() {
  if (!_internal_has_lobby_messages()) {
    clear_messages();
    set_has_lobby_messages();
    _impl_.messages_.lobby_messages_ = CreateMaybeMessage< ::Lobby_Messages >(GetArenaForAllocation());
  }
  return _impl_.messages_.lobby_messages_;
}
inline ::Lobby_Messages* Common_Message::mutable_lobby_messages() {
  ::Lobby_Messages* _msg = _internal_mutable_lobby_messages();
  // @@protoc_insertion_point(field_mutable:Common_Message.lobby_messages)
  return _msg;
}

// .Network_pb network = 7;
inline bool Common_Message::_internal_has_network() const {
  return messages_case() == kNetwork;
}
inline bool Common_Message::has_network() const {
  return _internal_has_network();
}
inline void Common_Message::set_has_network() {
  _impl_._oneof_case_[0] = kNetwork;
}
inline void Common_Message::clear_network() {
  if (_internal_has_network()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.network_;
    }
    clear_has_messages();
  }
}
inline ::Network_pb* Common_Message::release_network() {
  // @@protoc_insertion_point(field_release:Common_Message.network)
  if (_internal_has_network()) {
    clear_has_messages();
    ::Network_pb* temp = _impl_.messages_.network_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.network_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Network_pb& Common_Message::_internal_network() const {
  return _internal_has_network()
      ? *_impl_.messages_.network_
      : reinterpret_cast< ::Network_pb&>(::_Network_pb_default_instance_);
}
inline const ::Network_pb& Common_Message::network() const {
  // @@protoc_insertion_point(field_get:Common_Message.network)
  return _internal_network();
}
inline ::Network_pb* Common_Message::unsafe_arena_release_network() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.network)
  if (_internal_has_network()) {
    clear_has_messages();
    ::Network_pb* temp = _impl_.messages_.network_;
    _impl_.messages_.network_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_network(::Network_pb* network) {
  clear_messages();
  if (network) {
    set_has_network();
    _impl_.messages_.network_ = network;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.network)
}
inline ::Network_pb* Common_Message::_internal_mutable_network() {
  if (!_internal_has_network()) {
    clear_messages();
    set_has_network();
    _impl_.messages_.network_ = CreateMaybeMessage< ::Network_pb >(GetArenaForAllocation());
  }
  return _impl_.messages_.network_;
}
inline ::Network_pb* Common_Message::mutable_network() {
  ::Network_pb* _msg = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:Common_Message.network)
  return _msg;
}

// .Gameserver gameserver = 8;
inline bool Common_Message::_internal_has_gameserver() const {
  return messages_case() == kGameserver;
}
inline bool Common_Message::has_gameserver() const {
  return _internal_has_gameserver();
}
inline void Common_Message::set_has_gameserver() {
  _impl_._oneof_case_[0] = kGameserver;
}
inline void Common_Message::clear_gameserver() {
  if (_internal_has_gameserver()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.gameserver_;
    }
    clear_has_messages();
  }
}
inline ::Gameserver* Common_Message::release_gameserver() {
  // @@protoc_insertion_point(field_release:Common_Message.gameserver)
  if (_internal_has_gameserver()) {
    clear_has_messages();
    ::Gameserver* temp = _impl_.messages_.gameserver_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.gameserver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Gameserver& Common_Message::_internal_gameserver() const {
  return _internal_has_gameserver()
      ? *_impl_.messages_.gameserver_
      : reinterpret_cast< ::Gameserver&>(::_Gameserver_default_instance_);
}
inline const ::Gameserver& Common_Message::gameserver() const {
  // @@protoc_insertion_point(field_get:Common_Message.gameserver)
  return _internal_gameserver();
}
inline ::Gameserver* Common_Message::unsafe_arena_release_gameserver() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.gameserver)
  if (_internal_has_gameserver()) {
    clear_has_messages();
    ::Gameserver* temp = _impl_.messages_.gameserver_;
    _impl_.messages_.gameserver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_gameserver(::Gameserver* gameserver) {
  clear_messages();
  if (gameserver) {
    set_has_gameserver();
    _impl_.messages_.gameserver_ = gameserver;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.gameserver)
}
inline ::Gameserver* Common_Message::_internal_mutable_gameserver() {
  if (!_internal_has_gameserver()) {
    clear_messages();
    set_has_gameserver();
    _impl_.messages_.gameserver_ = CreateMaybeMessage< ::Gameserver >(GetArenaForAllocation());
  }
  return _impl_.messages_.gameserver_;
}
inline ::Gameserver* Common_Message::mutable_gameserver() {
  ::Gameserver* _msg = _internal_mutable_gameserver();
  // @@protoc_insertion_point(field_mutable:Common_Message.gameserver)
  return _msg;
}

// .Friend friend = 9;
inline bool Common_Message::_internal_has_friend_() const {
  return messages_case() == kFriend;
}
inline bool Common_Message::has_friend_() const {
  return _internal_has_friend_();
}
inline void Common_Message::set_has_friend_() {
  _impl_._oneof_case_[0] = kFriend;
}
inline void Common_Message::clear_friend_() {
  if (_internal_has_friend_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.friend__;
    }
    clear_has_messages();
  }
}
inline ::Friend* Common_Message::release_friend_() {
  // @@protoc_insertion_point(field_release:Common_Message.friend)
  if (_internal_has_friend_()) {
    clear_has_messages();
    ::Friend* temp = _impl_.messages_.friend__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.friend__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Friend& Common_Message::_internal_friend_() const {
  return _internal_has_friend_()
      ? *_impl_.messages_.friend__
      : reinterpret_cast< ::Friend&>(::_Friend_default_instance_);
}
inline const ::Friend& Common_Message::friend_() const {
  // @@protoc_insertion_point(field_get:Common_Message.friend)
  return _internal_friend_();
}
inline ::Friend* Common_Message::unsafe_arena_release_friend_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.friend)
  if (_internal_has_friend_()) {
    clear_has_messages();
    ::Friend* temp = _impl_.messages_.friend__;
    _impl_.messages_.friend__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_friend_(::Friend* friend_) {
  clear_messages();
  if (friend_) {
    set_has_friend_();
    _impl_.messages_.friend__ = friend_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.friend)
}
inline ::Friend* Common_Message::_internal_mutable_friend_() {
  if (!_internal_has_friend_()) {
    clear_messages();
    set_has_friend_();
    _impl_.messages_.friend__ = CreateMaybeMessage< ::Friend >(GetArenaForAllocation());
  }
  return _impl_.messages_.friend__;
}
inline ::Friend* Common_Message::mutable_friend_() {
  ::Friend* _msg = _internal_mutable_friend_();
  // @@protoc_insertion_point(field_mutable:Common_Message.friend)
  return _msg;
}

// .Auth_Ticket auth_ticket = 10;
inline bool Common_Message::_internal_has_auth_ticket() const {
  return messages_case() == kAuthTicket;
}
inline bool Common_Message::has_auth_ticket() const {
  return _internal_has_auth_ticket();
}
inline void Common_Message::set_has_auth_ticket() {
  _impl_._oneof_case_[0] = kAuthTicket;
}
inline void Common_Message::clear_auth_ticket() {
  if (_internal_has_auth_ticket()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.auth_ticket_;
    }
    clear_has_messages();
  }
}
inline ::Auth_Ticket* Common_Message::release_auth_ticket() {
  // @@protoc_insertion_point(field_release:Common_Message.auth_ticket)
  if (_internal_has_auth_ticket()) {
    clear_has_messages();
    ::Auth_Ticket* temp = _impl_.messages_.auth_ticket_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.auth_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Auth_Ticket& Common_Message::_internal_auth_ticket() const {
  return _internal_has_auth_ticket()
      ? *_impl_.messages_.auth_ticket_
      : reinterpret_cast< ::Auth_Ticket&>(::_Auth_Ticket_default_instance_);
}
inline const ::Auth_Ticket& Common_Message::auth_ticket() const {
  // @@protoc_insertion_point(field_get:Common_Message.auth_ticket)
  return _internal_auth_ticket();
}
inline ::Auth_Ticket* Common_Message::unsafe_arena_release_auth_ticket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.auth_ticket)
  if (_internal_has_auth_ticket()) {
    clear_has_messages();
    ::Auth_Ticket* temp = _impl_.messages_.auth_ticket_;
    _impl_.messages_.auth_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_auth_ticket(::Auth_Ticket* auth_ticket) {
  clear_messages();
  if (auth_ticket) {
    set_has_auth_ticket();
    _impl_.messages_.auth_ticket_ = auth_ticket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.auth_ticket)
}
inline ::Auth_Ticket* Common_Message::_internal_mutable_auth_ticket() {
  if (!_internal_has_auth_ticket()) {
    clear_messages();
    set_has_auth_ticket();
    _impl_.messages_.auth_ticket_ = CreateMaybeMessage< ::Auth_Ticket >(GetArenaForAllocation());
  }
  return _impl_.messages_.auth_ticket_;
}
inline ::Auth_Ticket* Common_Message::mutable_auth_ticket() {
  ::Auth_Ticket* _msg = _internal_mutable_auth_ticket();
  // @@protoc_insertion_point(field_mutable:Common_Message.auth_ticket)
  return _msg;
}

// .Friend_Messages friend_messages = 11;
inline bool Common_Message::_internal_has_friend_messages() const {
  return messages_case() == kFriendMessages;
}
inline bool Common_Message::has_friend_messages() const {
  return _internal_has_friend_messages();
}
inline void Common_Message::set_has_friend_messages() {
  _impl_._oneof_case_[0] = kFriendMessages;
}
inline void Common_Message::clear_friend_messages() {
  if (_internal_has_friend_messages()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.friend_messages_;
    }
    clear_has_messages();
  }
}
inline ::Friend_Messages* Common_Message::release_friend_messages() {
  // @@protoc_insertion_point(field_release:Common_Message.friend_messages)
  if (_internal_has_friend_messages()) {
    clear_has_messages();
    ::Friend_Messages* temp = _impl_.messages_.friend_messages_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.friend_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Friend_Messages& Common_Message::_internal_friend_messages() const {
  return _internal_has_friend_messages()
      ? *_impl_.messages_.friend_messages_
      : reinterpret_cast< ::Friend_Messages&>(::_Friend_Messages_default_instance_);
}
inline const ::Friend_Messages& Common_Message::friend_messages() const {
  // @@protoc_insertion_point(field_get:Common_Message.friend_messages)
  return _internal_friend_messages();
}
inline ::Friend_Messages* Common_Message::unsafe_arena_release_friend_messages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.friend_messages)
  if (_internal_has_friend_messages()) {
    clear_has_messages();
    ::Friend_Messages* temp = _impl_.messages_.friend_messages_;
    _impl_.messages_.friend_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_friend_messages(::Friend_Messages* friend_messages) {
  clear_messages();
  if (friend_messages) {
    set_has_friend_messages();
    _impl_.messages_.friend_messages_ = friend_messages;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.friend_messages)
}
inline ::Friend_Messages* Common_Message::_internal_mutable_friend_messages() {
  if (!_internal_has_friend_messages()) {
    clear_messages();
    set_has_friend_messages();
    _impl_.messages_.friend_messages_ = CreateMaybeMessage< ::Friend_Messages >(GetArenaForAllocation());
  }
  return _impl_.messages_.friend_messages_;
}
inline ::Friend_Messages* Common_Message::mutable_friend_messages() {
  ::Friend_Messages* _msg = _internal_mutable_friend_messages();
  // @@protoc_insertion_point(field_mutable:Common_Message.friend_messages)
  return _msg;
}

// .Network_Old network_old = 12;
inline bool Common_Message::_internal_has_network_old() const {
  return messages_case() == kNetworkOld;
}
inline bool Common_Message::has_network_old() const {
  return _internal_has_network_old();
}
inline void Common_Message::set_has_network_old() {
  _impl_._oneof_case_[0] = kNetworkOld;
}
inline void Common_Message::clear_network_old() {
  if (_internal_has_network_old()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.network_old_;
    }
    clear_has_messages();
  }
}
inline ::Network_Old* Common_Message::release_network_old() {
  // @@protoc_insertion_point(field_release:Common_Message.network_old)
  if (_internal_has_network_old()) {
    clear_has_messages();
    ::Network_Old* temp = _impl_.messages_.network_old_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.network_old_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Network_Old& Common_Message::_internal_network_old() const {
  return _internal_has_network_old()
      ? *_impl_.messages_.network_old_
      : reinterpret_cast< ::Network_Old&>(::_Network_Old_default_instance_);
}
inline const ::Network_Old& Common_Message::network_old() const {
  // @@protoc_insertion_point(field_get:Common_Message.network_old)
  return _internal_network_old();
}
inline ::Network_Old* Common_Message::unsafe_arena_release_network_old() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.network_old)
  if (_internal_has_network_old()) {
    clear_has_messages();
    ::Network_Old* temp = _impl_.messages_.network_old_;
    _impl_.messages_.network_old_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_network_old(::Network_Old* network_old) {
  clear_messages();
  if (network_old) {
    set_has_network_old();
    _impl_.messages_.network_old_ = network_old;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.network_old)
}
inline ::Network_Old* Common_Message::_internal_mutable_network_old() {
  if (!_internal_has_network_old()) {
    clear_messages();
    set_has_network_old();
    _impl_.messages_.network_old_ = CreateMaybeMessage< ::Network_Old >(GetArenaForAllocation());
  }
  return _impl_.messages_.network_old_;
}
inline ::Network_Old* Common_Message::mutable_network_old() {
  ::Network_Old* _msg = _internal_mutable_network_old();
  // @@protoc_insertion_point(field_mutable:Common_Message.network_old)
  return _msg;
}

// .Networking_Sockets networking_sockets = 13;
inline bool Common_Message::_internal_has_networking_sockets() const {
  return messages_case() == kNetworkingSockets;
}
inline bool Common_Message::has_networking_sockets() const {
  return _internal_has_networking_sockets();
}
inline void Common_Message::set_has_networking_sockets() {
  _impl_._oneof_case_[0] = kNetworkingSockets;
}
inline void Common_Message::clear_networking_sockets() {
  if (_internal_has_networking_sockets()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.networking_sockets_;
    }
    clear_has_messages();
  }
}
inline ::Networking_Sockets* Common_Message::release_networking_sockets() {
  // @@protoc_insertion_point(field_release:Common_Message.networking_sockets)
  if (_internal_has_networking_sockets()) {
    clear_has_messages();
    ::Networking_Sockets* temp = _impl_.messages_.networking_sockets_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.networking_sockets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Networking_Sockets& Common_Message::_internal_networking_sockets() const {
  return _internal_has_networking_sockets()
      ? *_impl_.messages_.networking_sockets_
      : reinterpret_cast< ::Networking_Sockets&>(::_Networking_Sockets_default_instance_);
}
inline const ::Networking_Sockets& Common_Message::networking_sockets() const {
  // @@protoc_insertion_point(field_get:Common_Message.networking_sockets)
  return _internal_networking_sockets();
}
inline ::Networking_Sockets* Common_Message::unsafe_arena_release_networking_sockets() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.networking_sockets)
  if (_internal_has_networking_sockets()) {
    clear_has_messages();
    ::Networking_Sockets* temp = _impl_.messages_.networking_sockets_;
    _impl_.messages_.networking_sockets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_networking_sockets(::Networking_Sockets* networking_sockets) {
  clear_messages();
  if (networking_sockets) {
    set_has_networking_sockets();
    _impl_.messages_.networking_sockets_ = networking_sockets;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.networking_sockets)
}
inline ::Networking_Sockets* Common_Message::_internal_mutable_networking_sockets() {
  if (!_internal_has_networking_sockets()) {
    clear_messages();
    set_has_networking_sockets();
    _impl_.messages_.networking_sockets_ = CreateMaybeMessage< ::Networking_Sockets >(GetArenaForAllocation());
  }
  return _impl_.messages_.networking_sockets_;
}
inline ::Networking_Sockets* Common_Message::mutable_networking_sockets() {
  ::Networking_Sockets* _msg = _internal_mutable_networking_sockets();
  // @@protoc_insertion_point(field_mutable:Common_Message.networking_sockets)
  return _msg;
}

// .Steam_Messages steam_messages = 14;
inline bool Common_Message::_internal_has_steam_messages() const {
  return messages_case() == kSteamMessages;
}
inline bool Common_Message::has_steam_messages() const {
  return _internal_has_steam_messages();
}
inline void Common_Message::set_has_steam_messages() {
  _impl_._oneof_case_[0] = kSteamMessages;
}
inline void Common_Message::clear_steam_messages() {
  if (_internal_has_steam_messages()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.steam_messages_;
    }
    clear_has_messages();
  }
}
inline ::Steam_Messages* Common_Message::release_steam_messages() {
  // @@protoc_insertion_point(field_release:Common_Message.steam_messages)
  if (_internal_has_steam_messages()) {
    clear_has_messages();
    ::Steam_Messages* temp = _impl_.messages_.steam_messages_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.steam_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Steam_Messages& Common_Message::_internal_steam_messages() const {
  return _internal_has_steam_messages()
      ? *_impl_.messages_.steam_messages_
      : reinterpret_cast< ::Steam_Messages&>(::_Steam_Messages_default_instance_);
}
inline const ::Steam_Messages& Common_Message::steam_messages() const {
  // @@protoc_insertion_point(field_get:Common_Message.steam_messages)
  return _internal_steam_messages();
}
inline ::Steam_Messages* Common_Message::unsafe_arena_release_steam_messages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.steam_messages)
  if (_internal_has_steam_messages()) {
    clear_has_messages();
    ::Steam_Messages* temp = _impl_.messages_.steam_messages_;
    _impl_.messages_.steam_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_steam_messages(::Steam_Messages* steam_messages) {
  clear_messages();
  if (steam_messages) {
    set_has_steam_messages();
    _impl_.messages_.steam_messages_ = steam_messages;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.steam_messages)
}
inline ::Steam_Messages* Common_Message::_internal_mutable_steam_messages() {
  if (!_internal_has_steam_messages()) {
    clear_messages();
    set_has_steam_messages();
    _impl_.messages_.steam_messages_ = CreateMaybeMessage< ::Steam_Messages >(GetArenaForAllocation());
  }
  return _impl_.messages_.steam_messages_;
}
inline ::Steam_Messages* Common_Message::mutable_steam_messages() {
  ::Steam_Messages* _msg = _internal_mutable_steam_messages();
  // @@protoc_insertion_point(field_mutable:Common_Message.steam_messages)
  return _msg;
}

// .Networking_Messages networking_messages = 15;
inline bool Common_Message::_internal_has_networking_messages() const {
  return messages_case() == kNetworkingMessages;
}
inline bool Common_Message::has_networking_messages() const {
  return _internal_has_networking_messages();
}
inline void Common_Message::set_has_networking_messages() {
  _impl_._oneof_case_[0] = kNetworkingMessages;
}
inline void Common_Message::clear_networking_messages() {
  if (_internal_has_networking_messages()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.messages_.networking_messages_;
    }
    clear_has_messages();
  }
}
inline ::Networking_Messages* Common_Message::release_networking_messages() {
  // @@protoc_insertion_point(field_release:Common_Message.networking_messages)
  if (_internal_has_networking_messages()) {
    clear_has_messages();
    ::Networking_Messages* temp = _impl_.messages_.networking_messages_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.messages_.networking_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Networking_Messages& Common_Message::_internal_networking_messages() const {
  return _internal_has_networking_messages()
      ? *_impl_.messages_.networking_messages_
      : reinterpret_cast< ::Networking_Messages&>(::_Networking_Messages_default_instance_);
}
inline const ::Networking_Messages& Common_Message::networking_messages() const {
  // @@protoc_insertion_point(field_get:Common_Message.networking_messages)
  return _internal_networking_messages();
}
inline ::Networking_Messages* Common_Message::unsafe_arena_release_networking_messages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Common_Message.networking_messages)
  if (_internal_has_networking_messages()) {
    clear_has_messages();
    ::Networking_Messages* temp = _impl_.messages_.networking_messages_;
    _impl_.messages_.networking_messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Common_Message::unsafe_arena_set_allocated_networking_messages(::Networking_Messages* networking_messages) {
  clear_messages();
  if (networking_messages) {
    set_has_networking_messages();
    _impl_.messages_.networking_messages_ = networking_messages;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common_Message.networking_messages)
}
inline ::Networking_Messages* Common_Message::_internal_mutable_networking_messages() {
  if (!_internal_has_networking_messages()) {
    clear_messages();
    set_has_networking_messages();
    _impl_.messages_.networking_messages_ = CreateMaybeMessage< ::Networking_Messages >(GetArenaForAllocation());
  }
  return _impl_.messages_.networking_messages_;
}
inline ::Networking_Messages* Common_Message::mutable_networking_messages() {
  ::Networking_Messages* _msg = _internal_mutable_networking_messages();
  // @@protoc_insertion_point(field_mutable:Common_Message.networking_messages)
  return _msg;
}

// uint32 source_ip = 128;
inline void Common_Message::clear_source_ip() {
  _impl_.source_ip_ = 0u;
}
inline uint32_t Common_Message::_internal_source_ip() const {
  return _impl_.source_ip_;
}
inline uint32_t Common_Message::source_ip() const {
  // @@protoc_insertion_point(field_get:Common_Message.source_ip)
  return _internal_source_ip();
}
inline void Common_Message::_internal_set_source_ip(uint32_t value) {
  
  _impl_.source_ip_ = value;
}
inline void Common_Message::set_source_ip(uint32_t value) {
  _internal_set_source_ip(value);
  // @@protoc_insertion_point(field_set:Common_Message.source_ip)
}

// uint32 source_port = 129;
inline void Common_Message::clear_source_port() {
  _impl_.source_port_ = 0u;
}
inline uint32_t Common_Message::_internal_source_port() const {
  return _impl_.source_port_;
}
inline uint32_t Common_Message::source_port() const {
  // @@protoc_insertion_point(field_get:Common_Message.source_port)
  return _internal_source_port();
}
inline void Common_Message::_internal_set_source_port(uint32_t value) {
  
  _impl_.source_port_ = value;
}
inline void Common_Message::set_source_port(uint32_t value) {
  _internal_set_source_port(value);
  // @@protoc_insertion_point(field_set:Common_Message.source_port)
}

inline bool Common_Message::has_messages() const {
  return messages_case() != MESSAGES_NOT_SET;
}
inline void Common_Message::clear_has_messages() {
  _impl_._oneof_case_[0] = MESSAGES_NOT_SET;
}
inline Common_Message::MessagesCase Common_Message::messages_case() const {
  return Common_Message::MessagesCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Announce_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Lobby_Messages_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Low_Level_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Network_pb_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Network_Old_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Networking_Sockets_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Networking_Messages_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Auth_Ticket_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Friend_Messages_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::Steam_Messages_Types> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_net_2eproto
